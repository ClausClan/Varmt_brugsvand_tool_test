<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <title>Varmt brugsvand dimensionering v0.20_beta - DS 439:2024 + R√∏r isolering DS452 </title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            display: flex;
            flex-direction: column;
        }
        .main-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .main-row {
            flex-grow: 1;
            overflow: hidden;
        }
        .scrollable-column {
            height: 100%;
            overflow-y: auto;
        }
.highlighted-row {
    background-color: #ffeb3b !important; /* Kraftig gul */
    color: #000 !important; /* Sort tekst for kontrast */
    outline: 3px solid #ffc107; /* Tydelig orange/guld kant */
    font-weight: bold;
    transition: all 0.5s ease;
    z-index: 100; /* Sikrer at den ligger 'ovenp√•' hvis der er skygger */
    position: relative; /* N√∏dvendig for at z-index og outline virker optimalt */
}
        #diagram, #diagram svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        .card-header h5 { margin-bottom: 0; }
        .accordion-button:not(.collapsed) { background-color: #eef7ff; }
        .streng-card { border-left: 4px solid #dc3545; }
        /* Standard: Varmt Freml√∏b (R√∏d, Solid) */
        .link-freml√∏b { stroke: #dc3545; stroke-width: 1.5px; }
        /* Standard: Varm Cirkulation (R√∏d, Stiplet) */
        .link-cirkulation_vv { stroke: #a71d2a; stroke-width: 1.5px; stroke-dasharray: 6, 4; }
        .node circle { stroke: #333; stroke-width: 0.5px; cursor: move; }
        .node.reparenting circle { stroke: #ffc107; stroke-width: 3px; }
        .dim-input:disabled { background-color: #e9ecef; }
        .link-text { font-size: 6px; fill: #333; }
        .name-input { font-size: 0.8rem; margin-left: 5px; }

		.info-popover {
            font-weight: bold;
            color: #0d6efd; /* Bootstrap Bl√• */
            cursor: help;
            font-size: 0.9em;
            margin-left: 4px;
            text-decoration: none;
        }

		/* Styles til Hj√¶lp Modal */
        .legend-box {
            width: 20px;
            height: 20px;
            display: inline-block;
            margin-right: 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .legend-line {
            width: 20px;
            height: 0px;
            display: inline-block;
            margin-right: 10px;
            border-top: 3px dashed; /* Stiplet linje */
        }
        
        /* NYT: Normaliser tabel-overskrifter */
        .card-body th {
            font-weight: normal;
        }

        /* Styles til H√∏jrekliks-menu og Undermenu */
        #context-menu .menu-item {
            position: relative;
            padding: 8px 15px;
            cursor: pointer;
        }
        #context-menu .menu-item:hover {
            background-color: #f2f2f2;
        }
        /* Pilen der indikerer undermenu */
        .has-submenu::after {
            content: "‚ñ∂";
            font-size: 0.7em;
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
        }
        /* Selve undermenuen */
        .context-submenu {
            display: none;
            position: absolute;
            left: 100%;
            top: -5px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            min-width: 180px;
            padding: 5px 0;
            z-index: 1001;
        }
        /* Vis undermenu ved hover */
        .menu-item:hover .context-submenu {
            display: block;
        }


    </style>
</head>
<body>
<div class="container-fluid main-container p-3">
    <input type="file" id="hiddenImportInput" accept=".json" style="display: none;" onchange="importProject(this.files[0])">

    <div class="d-flex justify-content-between align-items-center mb-3 border-bottom pb-2">
        
        <div class="dropdown">
            <button class="btn btn-outline-secondary border-0 p-2" type="button" data-bs-toggle="dropdown" aria-expanded="false" title="Projektmenu">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-list" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"/>
                </svg>
            </button>
            <ul class="dropdown-menu shadow">
                <li><h6 class="dropdown-header">Projekt</h6></li>
<li><a class="dropdown-item text-danger" href="#" onclick="resetProject()">üóëÔ∏è Nyt Projekt (Nulstil)</a></li>
                <li><a class="dropdown-item" href="#" onclick="renumberAndSortProject()">‚ú® Omd√∏b & Sorter (Clean Up)</a></li> <li><hr class="dropdown-divider"></li>
                <li><a class="dropdown-item" href="#" onclick="document.getElementById('hiddenImportInput').click()">üìÇ Import Projekt...</a></li>
                <li><a class="dropdown-item" href="#" onclick="exportProject()">üíæ Eksport Projekt</a></li>
            </ul>
        </div>

        <div class="text-center">
            <h1 class="h5 m-0 user-select-none">Varmt brugsvand dimensionering Version 0.20 Beta
            <small class="text-muted fw-normal">DS 439:2024 + DS 452</small></h1>
            <div style="font-size: 0.75rem; margin-top: -2px;">
                <a href="https://www.niras.dk" target="_blank" class="text-decoration-none text-secondary">¬© NIRAS</a>
            </div>
        </div>

        <button class="btn btn-outline-info rounded-circle d-flex align-items-center justify-content-center shadow-sm" style="width: 38px; height: 38px; font-weight: bold;" data-bs-toggle="modal" data-bs-target="#helpModal" title="Hj√¶lp & Info">
            ?
        </button>
    </div>
    
    <div class="row main-row">
        <div class="col-lg-6 scrollable-column">
            <div class="card mb-4">
                <div class="card-header"><h5><span class="badge bg-primary me-2">1</span>Input Data</h5></div>
                <div class="card-body">
                    
                    <div class="mb-3">
                        <label for="projectName" class="form-label fw-bold">Projekt Navn</label>
                        <input type="text" class="form-control" id="projectName" placeholder="Indtast projektnavn (f.eks. Adresse eller Sagsnr.)" oninput="setProjektEr√Ündret()">
                    </div>

                    <div class="accordion" id="inputAccordion">
                        <div class="accordion-item">
                            <h2 class="accordion-header"><button class="accordion-button" data-bs-toggle="collapse" data-bs-target="#collapseGenerelt" aria-expanded="true">Generelle Systemdata</button></h2>
                            <div id="collapseGenerelt" class="accordion-collapse collapse show" data-bs-parent="#inputAccordion">
                                <div class="accordion-body">
									<h6>Grundl√¶ggende Data</h6>
                                    <div class="row g-3 mb-3">
                                        <div class="col-md-6"><label class="form-label" for="pln">Forsyningstryk (p<sub>ln</sub>) <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Forsyningstryk (p_ln)" data-bs-content="Laveste normalt forekommende vandtryk (p_ln) i forsyningspunktet. Angives i Pascal (Pa). Jf. DS 439:2024, afsnit 6.2.2.1.">(?)</a></label><div class="input-group"><input id="pln" type="number" min="0" class="form-control" value="400000"><span class="input-group-text">Pa</span></div></div>
                                        <div class="col-md-6"><label class="form-label" for="forsyningens_kote">Forsyningens kote <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Forsyningens Kote" data-bs-content="Den geod√¶tiske kote (h√∏jde i meter) for forsyningspunktet. Anvendes som reference for beregning af l√∏fteh√∏jde til tapsteder. Jf. DS 439:2024, afsnit 6.3.5.1.">(?)</a></label><div class="input-group"><input id="forsyningens_kote" type="number" class="form-control allow-negative" value="0"><span class="input-group-text">m</span></div></div>
                                        <div class="col-md-6"><label class="form-label" for="min_tap_tryk">Min. tryk ved tapsted <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Minimumstryk ved Tapsted" data-bs-content="Det mindste tryk, der √∏nskes til r√•dighed *ved* tapstedet (efter koblingsledning og armatur). Dette er et designkrav (ofte 100.000 Pa / 1 bar). Jf. DS 439:2024, afsnit 6.3.5 vedr. tryktab i armaturer.">(?)</a></label><div class="input-group"><input id="min_tap_tryk" type="number" min="0" class="form-control" value="100000"><span class="input-group-text">Pa</span></div></div>
                                        <div class="col-md-6"><label class="form-label" for="T_v">Varmtvandstemperatur (T<sub>v</sub>) <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Varmtvandstemperatur (T_v)" data-bs-content="Dimensionerende temperatur for det varme brugsvand. B√∏r ikke falde til under 50¬∞C. En typisk designtemperatur er 55¬∞C. Jf. DS 439:2024, afsnit 5.6.1 og 6.6.2.1.">(?)</a></label><div class="input-group"><input id="T_v" type="number" min="0" class="form-control" value="55"><span class="input-group-text">¬∞C</span></div></div>
                                        <div class="col-md-6">
    <label class="form-label" for="T_omg">Omgivelsestemperatur (Indend√∏rs) <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Omgivelsestemperatur (Indend√∏rs)" data-bs-content="Den omgivende temperatur for r√∏r placeret i opvarmede rum (rum > 5¬∞C). Anvendes til beregning af varmetab. Jf. DS 452, afsnit 3.12 og 6.1.11.">(?)</a></label>
    <div class="input-group">
        <input id="T_omg" type="number" class="form-control" value="20">
        <span class="input-group-text">¬∞C</span>
    </div>
</div>
<div class="col-md-6">
    <label class="form-label" for="T_omg_ude">Omgivelsestemperatur (Udend√∏rs) <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Omgivelsestemperatur (Udend√∏rs)" data-bs-content="Den omgivende temperatur for r√∏r placeret 'ude' (i det fri, i jord, eller i uopvarmede rum < 5¬∞C). Anvendes til beregning af varmetab. Jf. DS 452, afsnit 3.18.">(?)</a></label>
    <div class="input-group">
        <input id="T_omg_ude" type="number" class="form-control" value="5">
        <span class="input-group-text">¬∞C</span>
    </div>
</div>
                                        <div class="col-md-6"><label class="form-label" for="dT"> Max ŒîT for VV cirkulation <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="√ònsket Delta-T (Cirkulation)" data-bs-content="Det acceptable temperaturtab (Delta-Temperatur) i cirkulationskredsen. Typisk 5 K (5¬∞C). Et lavere dT kr√¶ver h√∏jere flow for at d√¶kke samme varmetab. Jf. DS 439:2024, afsnit 5.5.13.">(?)</a></label><div class="input-group"><input id="dT" type="number" min="0.1" class="form-control" value="5"><span class="input-group-text">K</span></div></div>
<div class="col-md-6"><label class="form-label" for="lambda">Isoleringsevne (Lambda, Œª) <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Isoleringsevne (Lambda, Œª)" data-bs-content="Varmeledningsevnen for det valgte isoleringsmateriale. 0.037 W/m¬∑K er en typisk v√¶rdi for mineraluld. Bruges til beregning af varmetab jf. DS 452.">(?)</a></label><div class="input-group"><input id="lambda" type="number" min="0" step="0.001" class="form-control" value="0.037"><span class="input-group-text">W/m¬∑K</span></div></div>
                                    <hr>
                                    <h6>Automatisk Dimensionering</h6>
                                    <div class="form-check form-switch mb-2">
                                        <input class="form-check-input" type="checkbox" role="switch" id="autoDimToggle" onchange="toggleAutoDim(this.checked)" checked>
                                        <label class="form-check-label" for="autoDimToggle"><b>Aktiver "Design Mode"</b></label>
                                    </div>
<div class="row g-3" id="autoDimInputs">
    <div class="col-md-12">
        <label class="form-label" for="dimPrinciple">Dimensioneringsprincip <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Dimensioneringsprincip" data-bs-content="V√¶lg, hvordan 'Design Mode' skal prioritere. 'Kombineret' er standard. 'Global optimering' er langsommere, men fors√∏ger at finde den mest materialebesparende l√∏sning, der overholder alle globale trykkrav.">(?)</a></label>
        <select id="dimPrinciple" class="form-select" onchange="toggleGlobalOptimizationInputs()">
            <option value="combined" selected>Kombineret (Hastighed & Tryktab)</option>
            <option value="pressure_drop">Optimer kun efter Tryktab (Pa/m)</option>
            <option value="velocity">Optimer kun efter Hastighed (m/s)</option>
            <option value="min_velocity_pressure">Mindste tryktab (med min. hastighed)</option>
            <option value="global_pressure">Global optimering (mindste materiale)</option>
        </select>
    </div>

<div id="standardInputs" class="contents">
        <div class="row g-3">
            <div class="col-md-4"><label class="form-label" for="max_dp_m">Max Œîp Freml√∏b <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-title="Max Tryktab (Pa/m)" data-bs-content="Maksimalt tilladt tryktab pr. meter r√∏r (Pa/m). En almindelig designv√¶rdi er 150-500 Pa/m. Anvendes af 'Design Mode' til at v√¶lge r√∏rdimension.">(?)</a></label><div class="input-group"><input id="max_dp_m" type="number" min="0" value="500" class="form-control"><span class="input-group-text">Pa/m</span></div></div>
            <div class="col-md-4"><label class="form-label" for="max_v_f">Max v Freml√∏b <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-title="Max Hastighed (Freml√∏b)" data-bs-content="Maksimal tilladt vandhastighed (m/s) i freml√∏bsr√∏r. Anvendes af 'Design Mode'. H√∏je hastigheder kan medf√∏re st√∏j og korrosion. Jf. DS 439:2024, afsnit 5.4 og Tabel 10.">(?)</a></label><div class="input-group"><input id="max_v_f" type="number" min="0" value="1.0" class="form-control"><span class="input-group-text">m/s</span></div></div>
            <div class="col-md-4"><label class="form-label" for="min_v_f">Min v Freml√∏b <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-title="Min Hastighed (Freml√∏b)" data-bs-content="Mindste √∏nskede vandhastighed (m/s) i freml√∏bsr√∏r for at sikre turbulent str√∏mning og modvirke biofilm. Jf. DS 439:2024, afsnit 5.5.14.">(?)</a></label><div class="input-group"><input id="min_v_f" type="number" min="0" step="0.1" value="0.5" class="form-control"><span class="input-group-text">m/s</span></div></div>
            <div class="col-md-6"><label class="form-label" for="fittings_pct">Generelt till√¶g for fittings (DS 439) <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Fittings till√¶g (%)" data-bs-content="Procentvist till√¶g til det rene r√∏rtryktab for at d√¶kke enkeltmodstande (b√∏jninger, T-stykker), hvis disse ikke indtastes specifikt som Zeta. DS 439 anbefaler 25%, hvis specifikke data mangler.">(?)</a></label><div class="input-group"><input id="fittings_pct" type="number" min="0" class="form-control" value="25" placeholder="F.eks. 25"><span class="input-group-text">%</span></div></div>
            <div class="col-md-6"><label class="form-label" for="heat_loss_pct">Till√¶g til varmetab (Kuldebroer) <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Varmetabstill√¶g (%)" data-bs-content="Ekstra procenttill√¶g til det beregnede varmetab for at d√¶kke tab fra r√∏rb√¶ringer, ventiler og uisolerede komponenter. DS 452 anbefaler typisk 15% indvendigt og 25% udvendigt, hvis det ikke beregnes specifikt.">(?)</a></label><div class="input-group"><input id="heat_loss_pct" type="number" min="0" class="form-control" value="20" placeholder="F.eks. 20"><span class="input-group-text">%</span>
    </div>
</div>
        </div>
    </div>

    <div id="globalInputs" class="contents" style="display: none;">
        <hr>
        <h6 class="form-label">Gr√¶nse for Global Optimering</h6>
        <div class="form-check">
            <input class="form-check-input" type="radio" name="globalConstraint" id="globalConstraintDp" value="pressure_drop" checked>
            <label class="form-check-label" for="globalConstraintDp">Overhold Max Tryktab</label>
        </div>
        <div class="form-check">
            <input class="form-check-input" type="radio" name="globalConstraint" id="globalConstraintV">
            <label class="form-check-label" for="globalConstraintV">Overhold Max Hastighed</label>
        </div>
    </div>
</div>
                                    <hr>
									<h6>Brugerdefinerede Tapsteder</h6>
                                    <div id="customTapsteder" class="mb-3"></div>
                                    <div class="input-group mb-2">
                                        <input type="text" id="newTapName" class="form-control" placeholder="Navn" aria-label="Navn p√• nyt tapsted" title="Navn p√• det nye tapsted, f.eks. 'Stort Bad'">
                                        <input type="number" id="newTapQf" class="form-control" min="0" step="0.01" placeholder="qf (l/s)" aria-label="qf v√¶rdi" title="Normvandstr√∏m (qf) i l/s for det nye tapsted">
                                        <input type="checkbox" id="newTapApartment" class="form-check-input m-2" title="Lejlighed? (Vigtigt for Beholder Metode A)">
                                        <button class="btn btn-outline-primary" onclick="addCustomTapsted()" title="Gem det nye brugerdefinerede tapsted">Tilf√∏j</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="accordion-item">
                            <h2 class="accordion-header"><button class="accordion-button collapsed" data-bs-toggle="collapse" data-bs-target="#collapseFreml√∏b" aria-expanded="false">Varmtvands n√¶tv√¶rk (Tapsteder)			</button></h2>
                            <div id="collapseFreml√∏b" class="accordion-collapse collapse show" data-bs-parent="#inputAccordion">
                                <div class="accordion-body">
                                    <div id="strengeContainer"></div>
                                    <button class="btn btn-danger mt-2" aria-label="Tilf√∏j VV-streng" onclick="addStreng_vv()">+ Tilf√∏j VV-streng</button>
                                </div>
                            </div>
                        </div>
							<div class="accordion-item">
                            <h2 class="accordion-header"><button class="accordion-button collapsed" data-bs-toggle="collapse" data-bs-target="#collapseRetur" aria-expanded="false">Cirkulations Netv√¶rk</button></h2>
                            <div id="collapseRetur" class="accordion-collapse collapse show" data-bs-parent="#inputAccordion">
                                <div class="accordion-body">
<table class="table table-sm table-borderless mb-0" style="table-layout: fixed;">
                    <thead>
                        <tr>
                            <th style="width: 20%;">ID/Navn</th>
                            <th style="width: 18%;">For√¶lder</th>
                            <th style="width: 22%;">Mat./Type</th>
                            <th style="width: 10%;">Plac.</th>
							<th style="width: 12%;">Isol. Klasse</th> 
							<th style="width: 10%;">Dim [mm]</th>
                            <th style="width: 8%;">L√¶ngde [m]</th>
                            <th style="width: 7%;">Zeta [Œ∂]</th>
                            <th style="width: 5%;"></th>
                        </tr>
                    </thead>
                    <tbody id="returContainerBody">
                        </tbody>
                </table>
					<div class="d-flex gap-2 mt-2">
				    <button class="btn btn-primary" style="white-space: nowrap;" aria-label="Tilf√∏j retur-r√∏r" onclick="addCirkulationRor()">+ Cirkulationsr√∏r</button>
				    <div class="vr"></div>
   					<button class="btn btn-warning" style="white-space: nowrap;" aria-label="Tilf√∏j cirkulationsventil" onclick="addValve()">+ Cirkulationsventil</button>
                                </div>
</div>

                            </div>
                        </div>
                    </div>
                </div>
            </div>
<div class="card shadow-sm">
                <div class="card-header d-flex justify-content-between align-items-center py-2">
                    <h5 class="m-0"><span class="badge bg-success me-2">2</span>Resultater</h5>
                    
                    <div class="d-flex align-items-center gap-3">
                        <div class="form-check form-switch mb-0" title="Vis komponent-navne i diagram og lister">
                            <input class="form-check-input" type="checkbox" id="toggleNames" role="switch" onchange="toggleDisplayNames(this.checked)">
                            <label class="form-check-label small" for="toggleNames">Vis Navne</label>
                        </div>

                        <div class="dropdown">
                            <button class="btn btn-link text-dark p-0 text-decoration-none border-0" type="button" data-bs-toggle="dropdown" aria-expanded="false" title="Rapporter & Data">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-three-dots-vertical" viewBox="0 0 16 16">
                                    <path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
                                </svg>
                            </button>
                            <ul class="dropdown-menu dropdown-menu-end shadow">
                                <li><h6 class="dropdown-header">Eksport & Print</h6></li>
                                <li>
                                    <a class="dropdown-item" href="#" onclick="showCalculationReport()">
                                        üìÑ Vis Rapport (HTML/Print)
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="#" onclick="exportDetailedResults()">
                                        üìä Eksport Detaljer (JSON)
                                    </a>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="card-body">
<div class="d-grid mb-3">
        <button class="btn btn-success py-2 shadow-sm fw-bold" onclick="beregn()">
            ‚ñ∂ Beregn Hele Systemet
        </button>
    </div>
                    <div id="advarsler" class="mb-3"></div>
<ul class="nav nav-tabs" role="tablist">
  <li class="nav-item" role="presentation"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#summary" type="button">Opsummering</button></li>
  <li class="nav-item" role="presentation"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#beholder" type="button">Beholder</button></li>
  <li class="nav-item" role="presentation"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#r√∏r" type="button">R√∏rdata</button></li>
  <li class="nav-item" role="presentation"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#cirkulation" type="button">Cirkulation</button></li>
</ul>
                    <div class="tab-content pt-3">
                      <div class="tab-pane fade show active" id="summary" role="tabpanel"><table class="table table-sm"><tbody id="summaryTableBody"></tbody></table></div>
<div class="tab-pane fade" id="beholder" role="tabpanel">
    <div id="beholderResult" class="mt-3">
<div class="mb-4">
            <h5>V√¶lg beregningsmetode</h5>
            
            <div class="form-check mb-2">
                <input class="form-check-input" type="radio" name="beholderMetode" id="metodeA" value="A" onchange="toggleBeholderMetode()" checked>
                <label class="form-check-label" for="metodeA">
                    <b>Metode A: Etageboliger (DS 439)</b>
                    <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Metode A (P-V Diagram)" data-bs-content="Den officielle metode til etageboliger med mange lejligheder. Beregningen baseres p√• antallet af 'Normallejligheder' og bruger DS 439 P-V diagrammer til at finde sammenh√¶ngen mellem effekt og volumen. Kr√¶ver tapsteder af typen 'Lejlighed'.">(?)</a>
                    <br><small class="text-muted">Standard for boligblokke. Kr√¶ver tapsteder defineret som 'Lejlighed'.</small>
                </label>
            </div>
            <div id="metodeA_warning" class="alert alert-warning d-none mt-1 py-2">
                <small><b>OBS:</b> Du har valgt Metode A, men der er ingen tapsteder markeret som "Lejlighed" i dit projekt. Tilf√∏j tapsteder af typen "Lejlighed (standard)" for at bruge denne metode.</small>
            </div>

            <div class="form-check mb-2">
                <input class="form-check-input" type="radio" name="beholderMetode" id="metodeB" value="B" onchange="toggleBeholderMetode()">
                <label class="form-check-label" for="metodeB">
                    <b>Metode B: Enfamiliehuse & Mindre Bygninger</b>
                    <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Metode B (St√∏rste Tappested)" data-bs-content="Simpel dimensionering baseret p√• det st√∏rste enkelte tappested (f.eks. badekar eller bruser) og en √∏nsket opvarmningstid. Velegnet til enfamiliehuse, sommerhuse og sm√• erhverv.">(?)</a>
                    <br><small class="text-muted">Baseret p√• st√∏rste enkeltforbruger (f.eks. badekar).</small>
                </label>
            </div>

            <div class="form-check mb-2">
                <input class="form-check-input" type="radio" name="beholderMetode" id="metodeC" value="C" onchange="toggleBeholderMetode()">
                <label class="form-check-label" for="metodeC">
                    <b>Metode C: Specialbyggeri (Tappem√∏nster)</b>
                    <a tabindex="0" class="info-popover" role="button" data-bs-toggle="popover" data-bs-placement="right" data-bs-title="Metode C (Simulering)" data-bs-content="Avanceret beregning hvor du definerer et specifikt tappem√∏nster over tid (f.eks. 20 brusere kl. 08:00). Bruges til sportshaller, hoteller, campingpladser og industri.">(?)</a>
                    <br><small class="text-muted">For sportshaller, industri og bygninger med s√¶rlige spidsbelastninger.</small>
                </label>
            </div>
        </div>
        <hr>

        <div id="metodeA_inputs" class="beholder-metode">
            <h6 class="mb-3">Input for Metode A</h6>
            <div id="metodeA_content"></div>
        </div>

        <div id="metodeB_inputs" class="beholder-metode" style="display:none;">
            <h6 class="mb-3">Input for Metode B</h6>
            <div class="row g-3">
                <div class="col-md-4"><label class="form-label">Maks. flow (st√∏rste forbruger)</label><div class="input-group"><input id="metodeB_flow" type="number" step="0.01" value="0.3" class="form-control"><span class="input-group-text">l/s</span></div></div>
                <div class="col-md-4"><label class="form-label">Varighed af tapning</label><div class="input-group"><input id="metodeB_varighed" type="number" value="10" class="form-control"><span class="input-group-text">min</span></div></div>
                <div class="col-md-4"><label class="form-label">Varmekildens effekt</label><div class="input-group"><input id="metodeB_effekt" type="number" value="25" class="form-control"><span class="input-group-text">kW</span></div></div>
            </div>
        </div>
        
        <div id="metodeC_inputs" class="beholder-metode" style="display:none;">
            <h6 class="mb-3">Input for Metode C</h6>
            <div class="row g-3">
                <div class="col-md-6"><label class="form-label">Varmekildens effekt</label><div class="input-group"><input id="metodeC_effekt" type="number" value="40" class="form-control"><span class="input-group-text">kW</span></div></div>
            </div>
            <p class="mt-3 mb-1">Defin√©r tappem√∏nster for spidsbelastningsperioden:</p>
            <table class="table table-sm table-bordered">
                <thead><tr><th>Flow [l/s]</th><th>Starttid [min]</th><th>Varighed [min]</th><th></th></tr></thead>
                <tbody id="metodeC_tablebody">
                    <tr>
                        <td><input type="number" step="0.01" class="form-control form-control-sm" value="0.3"></td>
                        <td><input type="number" class="form-control form-control-sm" value="0"></td>
                        <td><input type="number" class="form-control form-control-sm" value="10"></td>
                        <td><button class="btn btn-sm btn-outline-danger" onclick="this.closest('tr').remove()">&times;</button></td>
                    </tr>
                    <tr>
                        <td><input type="number" step="0.01" class="form-control form-control-sm" value="0.3"></td>
                        <td><input type="number" class="form-control form-control-sm" value="2"></td>
                        <td><input type="number" class="form-control form-control-sm" value="8"></td>
                        <td><button class="btn btn-sm btn-outline-danger" onclick="this.closest('tr').remove()">&times;</button></td>
                    </tr>
                </tbody>
            </table>
            <button class="btn btn-sm btn-outline-secondary" onclick="addTappemonsterRow()">+ Tilf√∏j r√¶kke</button>
        </div>

        <div class="mt-4">
            <button class="btn btn-primary w-100" onclick="beregnBeholder()">Beregn Beholder</button>
        </div>
        <div class="mt-3 p-3 bg-light rounded">
            <h5>Beregnet Beholdervolumen</h5>
            <p class="display-6" id="beholderResultatVolumen">- L</p>
            <small id="beholderResultatBeskrivelse" class="text-muted">Resultatet vises her efter beregning.</small>
        </div>
    </div>
</div>
                      <div class="tab-pane fade" id="r√∏r" role="tabpanel"><table class="table table-sm table-bordered table-hover" id="r√∏rResultTable"><thead></thead><tbody></tbody></table></div>
<div class="tab-pane fade" id="cirkulation" role="tabpanel"><table class="table table-sm table-bordered table-hover" id="cirkResultTable"><thead></thead><tbody></tbody></table></div>
                    </div>
					</div>
                </div>
            </div>
        </div> <div class="col-lg-6 d-flex flex-column">
            <div class="card flex-grow-1">
            <div class="card-header"><h5><span class="badge bg-secondary me-2">3</span>Interaktivt Diagram</h5></div>
                <div class="card-body p-0 flex-grow-1 d-flex flex-column">
                    <div class="p-2 d-flex gap-2">
                        <button class="btn btn-outline-secondary flex-grow-1" onclick="buildNetworkAndRender()">Opdater Diagram</button>
                        <button class="btn btn-outline-primary" onclick="zoomToFit()" title="Zoom s√• alt passer i billedet">Zoom Alt</button>
                    </div>
              
<div class="card mb-2">
    <div class="card-body p-2">
        <div class="d-flex align-items-center gap-3 mb-2">
            <strong class="me-2">Farvevisning:</strong>
            <div class="form-check">
                <input class="form-check-input" type="radio" name="visMode" id="visIngen" value="none" onclick="updateDiagramStyles()" checked>
                <label class="form-check-label" for="visIngen">Ingen</label>
            </div>
            <div class="form-check">
                <input class="form-check-input" type="radio" name="visMode" id="visHastighed" value="velocity" onclick="updateDiagramStyles()">
                <label class="form-check-label" for="visHastighed">Hastighed</label>
            </div>
            <div class="form-check">
                <input class="form-check-input" type="radio" name="visMode" id="visTryktab" value="pressure_drop" onclick="updateDiagramStyles()">
                <label class="form-check-label" for="visTryktab">Tryktab (Pa/m)</label>
            </div>
            <div class="form-check">
                <input class="form-check-input" type="radio" name="visMode" id="visVarmetab" value="heat_loss" onclick="updateDiagramStyles()">
                <label class="form-check-label" for="visVarmetab">Varmetab (W/m)</label>
            </div>
            <div class="form-check">
                <input class="form-check-input" type="radio" name="visMode" id="visTemp" value="temp" onclick="updateDiagramStyles()">
                <label class="form-check-label" for="visTemp">Temperatur (¬∞C)</label>
            </div>
             <div class="vr"></div>
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" role="switch" id="visLegend" onclick="updateLegend()" checked>
                <label class="form-check-label" for="visLegend">Vis farveskala</label>
            </div>
        </div>
        <div class="d-flex align-items-center gap-3 border-top pt-2">
            <strong class="me-2">Vis data:</strong>
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" role="switch" id="visDim" onclick="updateDiagramStyles()">
                <label class="form-check-label" for="visDim">Dimension</label>
            </div>
	    <div class="form-check form-switch">
	        <input class="form-check-input" type="checkbox" role="switch" id="visFlow" onclick="updateDiagramStyles()">
	        <label class="form-check-label" for="visFlow">Vandm√¶ngde (l/s)</label>
	    </div>
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" role="switch" id="visTryktabLabel" onclick="updateDiagramStyles()">
                <label class="form-check-label" for="visTryktabLabel">Tryktab (Pa/m)</label>
            </div>
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" role="switch" id="visHastighedLabel" onclick="updateDiagramStyles()">
                <label class="form-check-label" for="visHastighedLabel">Hastighed</label>
            </div>
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" role="switch" id="visLaengde" onclick="updateDiagramStyles()">
                <label class="form-check-label" for="visLaengde">L√¶ngde</label>
            </div>
            <div class="vr"></div>
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" role="switch" id="visKritisk" onclick="updateDiagramStyles()">
                <label class="form-check-label" for="visKritisk">Vis kritisk streng</label>
            </div>
        </div>
    </div>
</div>  
<div id="diagram" class="flex-grow-1 position-relative">
                        <div id="diagram-legend" class="p-2 bg-light border rounded" style="position:absolute; bottom:10px; right:10px; display:none; font-size: 0.8rem;"></div>
                    </div>
                </div> </div> </div> </div> </div> <div class="modal fade" id="helpModal" tabindex="-1" aria-labelledby="helpModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header bg-light">
                <h5 class="modal-title" id="helpModalLabel">‚ÑπÔ∏è Hj√¶lp & Information</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
<div class="modal-body">
    
    <div class="text-center mb-4 pb-3 border-bottom">
        <h5 class="mb-1">Varmt Brugsvand Dimensioneringsv√¶rkt√∏j</h5>
        <p class="text-muted mb-1">Version 0.20 Beta (Integreret Fysisk Optimering)</p>
        <p class="small text-muted mb-0">Beregning jf. DS 439:2024 & DS 452</p>
    </div>

    <ul class="nav nav-tabs mb-3" id="helpTabs" role="tablist">
        <li class="nav-item" role="presentation">
            <button class="nav-link active" id="help-legend-tab" data-bs-toggle="tab" data-bs-target="#help-legend" type="button">Signatur</button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="help-calc-tab" data-bs-toggle="tab" data-bs-target="#help-calc" type="button">Beregningsmetoder</button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="help-input-tab" data-bs-toggle="tab" data-bs-target="#help-input" type="button">Input & Till√¶g</button>
        </li>
    </ul>

    <div class="tab-content" id="helpTabContent">
        
        <div class="tab-pane fade show active" id="help-legend" role="tabpanel">
            <h6 class="text-primary mb-3">R√∏rtyper & Farver (Model B)</h6>
            <div class="row g-3">
                <div class="col-md-6">
                    <strong class="small text-uppercase text-danger">Varmt Brugsvand (R√∏d)</strong>
                    <ul class="list-group list-group-flush small mt-2">
                        <li class="list-group-item d-flex align-items-center px-0">
                            <span class="legend-box" style="background-color: #8b0000;"></span>
                            <div><b>Hovedledning</b> (Frem)<br><span class="text-muted">Forsyner flere streng-sektioner.</span></div>
                        </li>
                        <li class="list-group-item d-flex align-items-center px-0">
                            <span class="legend-box" style="background-color: #dc3545;"></span>
                            <div><b>Fordelingsledning</b> (Frem)<br><span class="text-muted">Forsyner >1 tapsted i en streng.</span></div>
                        </li>
                        <li class="list-group-item d-flex align-items-center px-0">
                            <span class="legend-box" style="background-color: #f08080;"></span>
                            <div><b>Koblingsledning</b> (Frem)<br><span class="text-muted">Forsyner 1 tapsted. (Ofte uisoleret).</span></div>
                        </li>
                        <li class="list-group-item d-flex align-items-center px-0">
                            <span class="legend-line" style="border-color: #a71d2a; border-style: dashed;"></span>
                            <div><b>Cirkulation</b> (Retur)<br><span class="text-muted">Returl√∏b til beholder.</span></div>
                        </li>
                    </ul>
                </div>
                <div class="col-md-6">
                    <strong class="small text-uppercase text-secondary">Komponenter</strong>
                    <ul class="list-group list-group-flush small mt-2">
                        <li class="list-group-item d-flex align-items-center px-0">
                            <span class="dot" style="background-color:#198754; width:12px; height:12px; border-radius:50%; margin-right:10px;"></span>
                            <div><b>Tapsted</b><br><span class="text-muted">Forbrugssted (f.eks. Brus, H√•ndvask).</span></div>
                        </li>
                        <li class="list-group-item d-flex align-items-center px-0">
                            <span class="dot" style="background-color:#6f42c1; width:12px; height:12px; transform:rotate(45deg); margin-right:10px;"></span>
                            <div><b>Ventil</b><br><span class="text-muted">Strengreguleringsventil (Statisk/Dynamisk).</span></div>
                        </li>
                        <li class="list-group-item d-flex align-items-center px-0">
                            <span class="dot" style="background-color:#333; width:14px; height:14px; border-radius:50%; margin-right:10px;"></span>
                            <div><b>Beholder</b><br><span class="text-muted">Varmekilde / Startpunkt.</span></div>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="tab-pane fade" id="help-calc" role="tabpanel">
            <div class="accordion accordion-flush" id="calcAccordion">
                
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed py-2 fw-bold" type="button" data-bs-toggle="collapse" data-bs-target="#helpCalcQd">
                            üíß 1. Spidslast (qd)
                        </button>
                    </h2>
                    <div id="helpCalcQd" class="accordion-collapse collapse" data-bs-parent="#calcAccordion">
                        <div class="accordion-body small bg-light">
                            <p>Beregnes iht. <b>DS 439:2024</b> formel (1). Summen af normvandstr√∏mme ($q_f$) konverteres til en dimensionsgivende vandstr√∏m ($q_d$) via den "bl√∏de" kvadratrodsformel, der tager h√∏jde for samtidighed.</p>
                        </div>
                    </div>
                </div>

                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed py-2 fw-bold" type="button" data-bs-toggle="collapse" data-bs-target="#helpCalcDp">
                            üìâ 2. Tryktab & Tabelvisning
                        </button>
                    </h2>
                    <div id="helpCalcDp" class="accordion-collapse collapse" data-bs-parent="#calcAccordion">
                        <div class="accordion-body small bg-light">
                            <p><b>R√∏rfriktion:</b> Beregnes med <i>Darcy-Weisbach</i> ligningen. Friktionsfaktoren ($\lambda$) findes iterativt via <i>Colebrook-White</i> formlen.</p>
                            <div class="alert alert-info p-2 mt-2">
                                <strong>Vigtigt om resultattabellen:</strong> For at give fuldt overblik er tryktabet splittet op:
                                <ul>
                                    <li><b>R√∏rfriktion [Pa/m]:</b> Det rene r√∏rtab inkl. det generelle procenttill√¶g. <u>Det er dette tal, optimeringen styrer r√∏rst√∏rrelsen efter.</u></li>
                                    <li><b>Fittings [Pa]:</b> Det absolutte tryktab fra specifikke ventiler, b√∏jninger (Zeta) samt det generelle procenttill√¶g.</li>
                                    <li><b>Total [Pa]:</b> Summen af r√∏rfriktion og fittings.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed py-2 fw-bold text-primary" type="button" data-bs-toggle="collapse" data-bs-target="#helpCalcCirc">
                            üîÑ 3. Cirkulation & Optimering (NY!)
                        </button>
                    </h2>
                    <div id="helpCalcCirc" class="accordion-collapse collapse" data-bs-parent="#calcAccordion">
                        <div class="accordion-body small bg-light">
                            <p>Cirkulationssystemet beregnes via en avanceret <b>Iterativ Konvergens-algoritme</b>, der sikrer overholdelse af temperaturkravet ($50^{\circ}C$) i alle dele af anl√¶gget.</p>
                            <ol>
                                <li><b>Varmetabs-analyse:</b> Varmetabet beregnes for hvert r√∏r (inkl. till√¶g for kuldebroer).</li>
                                <li><b>Andelsprincippet:</b> Varmetabet i hovedledninger fordeles proportionalt ud p√• de strenge, der benytter dem.</li>
                                <li><b>Termisk Feedback Loop:</b> 
                                    <ul>
                                        <li>Programmet simulerer temperaturen gennem hele anl√¶gget.</li>
                                        <li>Hvis returtemperaturen ved beholderen for en streng falder under m√•let ($T_v - \Delta T$), <b>booster</b> programmet flowet i den p√•g√¶ldende streng, indtil m√•let er n√•et.</li>
                                    </ul>
                                </li>
                                <li><b>Integreret Dimensionering:</b> N√•r flowet stiger, tjekker programmet i samme arbejdsgang, om r√∏rst√∏rrelsen i returl√∏bet skal √∏ges for at overholde kravene til hastighed og tryktab (Pa/m).</li>
                            </ol>
                            <p><b>Resultat:</b> Et anl√¶g i fysisk balance, hvor flowet er pr√¶cis stort nok til at holde temperaturen, og r√∏rene er store nok til at b√¶re flowet.</p>
                        </div>
                    </div>
                </div>

                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed py-2 fw-bold" type="button" data-bs-toggle="collapse" data-bs-target="#helpCalcValve">
                            ‚öôÔ∏è 4. Ventil Dimensionering
                        </button>
                    </h2>
                    <div id="helpCalcValve" class="accordion-collapse collapse" data-bs-parent="#calcAccordion">
                        <div class="accordion-body small bg-light">
                            <p>Programmet v√¶lger automatisk den optimale ventil baseret p√• typen:</p>
                            <ul>
                                <li><b>Dynamisk (fx Frese Alpha):</b> Ventilen v√¶lges ud fra max flow. 
                                    <br>Pumpen dimensioneres til at levere ventilens <i>Minimums Starttryk</i> (Min. $\Delta p$) til den kritiske streng. Indstillingen er altid "Auto".</li>
                                <li><b>Statisk (fx IMI STAD):</b> Ventilen v√¶lges, s√• den ved en fornuftig forindstilling (2.5 omdr) har et tryktab p√• mellem 3 kPa (for autoritet) og 25 kPa (for at undg√• st√∏j).
                                    <br>I resultattabellen beregnes og vises den n√∏dvendige <b>Kv-v√¶rdi</b>, som installat√∏ren skal indstille ventilen til for at fjerne overskydende tryk.</li>
                            </ul>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <div class="tab-pane fade" id="help-input" role="tabpanel">
            <h6 class="text-primary">Sikkerhedsfaktorer & Till√¶g</h6>
            <p class="small text-muted">For at sikre en robust installation i praksis, anvendes to centrale till√¶g:</p>
            
            <div class="list-group mb-3">
                <div class="list-group-item">
                    <div class="d-flex w-100 justify-content-between">
                        <h6 class="mb-1">1. Generelt till√¶g for fittings</h6>
                        <small class="text-muted">Standard: +25%</small>
                    </div>
                    <p class="mb-1 small">L√¶gges oven i det beregnede r√∏rfriktionstab. D√¶kker tryktab i b√∏jninger, T-stykker og muffer, som ikke er tegnet specifikt. Jf. DS 439 anbefales 25%, hvis detaljerede data mangler.</p>
                </div>
                <div class="list-group-item">
                    <div class="d-flex w-100 justify-content-between">
                        <h6 class="mb-1">2. Till√¶g til varmetab (Kuldebroer)</h6>
                        <small class="text-muted">Standard: +20%</small>
                    </div>
                    <p class="mb-1 small">L√¶gges oven i det teoretiske varmetab (U-v√¶rdi). D√¶kker varmetab gennem r√∏rb√¶ringer, uisolerede ventiler, flanger og samlinger, som bryder isoleringen. Dette sikrer, at cirkulationsflowet bliver stort nok i praksis til at d√¶kke det <i>reelle</i> tab. Jf. DS 452/SBI.</p>
                </div>
            </div>

            <h6 class="text-primary mt-3">Isolering (DS 452)</h6>
            <p class="small">Isoleringstykkelsen beregnes automatisk ("Auto") baseret p√• r√∏rets <b>kategori</b> og <b>placering</b>:</p>
            <ul class="small">
                <li><b>Opvarmet rum:</b> Klasse 4 (Hoved- og fordelingsledninger).</li>
                <li><b>Koblingsledninger:</b> Klasse 4 foresl√•s som standard ("Sikker side"). Hvis r√∏ret er i samme rum som tapstedet, kan du manuelt √¶ndre det til <b>Klasse 0</b> (Uisoleret) jf. DS 452.</li>
                <li><b>Udvendig / Uopvarmet:</b> Klasse 6 (Maksimal isolering).</li>
            </ul>
        </div>

    </div>
    
    <div class="alert alert-warning mt-3 mb-0 p-2 small">
        <div class="d-flex align-items-start">
            <span class="me-2 fs-5">üíæ</span>
            <div>
                <strong>HUSK AT GEMME!</strong><br>
                Dine data gemmes kun midlertidigt i browseren. Brug "Eksport Projekt" i menuen for at gemme en fil til din computer.
            </div>
        </div>
    </div>
</div>
            <div class="modal-footer bg-light justify-content-between">
                <a href="mailto:cwa@niras.dk?subject=Feedback%20Varmt%20Brugsvand%20Tool%20v0.15" class="btn btn-outline-secondary btn-sm">
                    ‚úâÔ∏è Send Feedback
                </a>
                <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Luk</button>
            </div>
        </div>
    </div>
</div>

<template id="strengTemplate">
    <div class="card mb-3 streng-card" data-type="streng-card">
        <div class="card-header bg-light d-flex justify-content-between align-items-center">
            <h6 class="mb-0"><span class="id-text"></span><input type="text" class="name-input d-none name-text" placeholder="Navn" title="Giv strengen et unikt navn"></h6>
            <button class="btn btn-sm btn-outline-danger" aria-label="Fjern streng" onclick="removeElement(this)" title="Fjern hele strengen">&times; Fjern</button>
        </div>
        <div class="card-body">
            
            <h6>R√∏r</h6>
            <table class="table table-sm table-borderless mb-0" style="table-layout: fixed;">
                <thead>
                    <tr>
                        <th style="width: 18%;">ID/Navn</th>
                        <th style="width: 15%;">For√¶lder</th>
                        <th style="width: 12%;">Mat.</th>
                        <th style="width: 13%;">Plac.</th>
                        <th style="width: 12%;">Isol. Klasse</th> <th style="width: 10%;">Dim [mm]</th>
                        <th style="width: 10%;">L√¶ngde [m]</th>
                        <th style="width: 7%;">Zeta [Œ∂]</th>
                        <th style="width: 5%;"></th>
                    </tr>
                </thead>
                <tbody class="ror-container">
                    </tbody>
            </table>
            <button class="btn btn-sm btn-outline-secondary mt-1" aria-label="Tilf√∏j r√∏r" onclick="addRorSektion(this, 'ror_vv')">+ Varmtvandsr√∏r</button>
            
            <hr>
            
            <h6 class="mt-3">Tapsteder</h6>
            <table class="table table-sm table-borderless mb-0" style="table-layout: fixed;">
                <thead>
                    <tr>
                        <th style="width: 20%;">ID/Navn</th>
                        <th style="width: 18%;">For√¶lder</th>
                        <th style="width: 32%;">Type</th>
                        <th style="width: 10%;">qf [l/s]</th>
                        <th style="width: 10%;">Kote [m]</th>
                        <th style="width: 5%;">Syst.</th>
                        <th style="width: 5%;"></th>
                    </tr>
                </thead>
                <tbody class="tapsted-container">
                    </tbody>
            </table>
            <button class="btn btn-sm btn-outline-secondary mt-1" aria-label="Tilf√∏j tapsted" onclick="addTapsted(this)">+ Tapsted</button>
            
            <hr>
            
            <h6>Cirkulationskobling</h6>
            <div class="row gx-2">
                <div class="col"><label class="form-label-sm" for="circ-start">Startpunkt</label><select class="form-select form-select-sm circ-start" id="circ-start" title="Startpunkt for cirkulation (ofte det fjerneste r√∏r i strengen)"></select></div>
                <div class="col"><label class="form-label-sm" for="circ-end">Tilsluttes cirkulationsr√∏r</label><select class="form-select form-select-sm circ-end" id="circ-end" title="Tilslutningspunkt for cirkulation (skal v√¶re et retur-r√∏r, en ventil eller Beholder)"><option value="">Ingen</option></select></div>
                <div class="col"><label class="form-label-sm" for="circ-zeta">Zeta (kobling)</label><div class="input-group"><input type="number" min="0" class="form-control form-control-sm circ-zeta" value="0" title="Eventuel enkeltmodstand (zeta) i selve cirkulationskoblingen"><span class="input-group-text">Œ∂</span></div></div>
            </div>
        </div>
    </div>
</template>

<datalist id="insulationClassOptions">
    <option value="Auto"></option>
    <option value="Kl. 0"></option>
    <option value="Kl. 1"></option>
    <option value="Kl. 2"></option>
    <option value="Kl. 3"></option>
    <option value="Kl. 4"></option>
    <option value="Kl. 5"></option>
    <option value="Kl. 6"></option>
</datalist>

<template id="returRorTRTemplate">
    <tr data-type="cirkulation_vv">
        <td>
            <span class="input-group input-group-sm">
                <span class="input-group-text id-text"></span>
                <input type="text" class="form-control name-input d-none name-text" placeholder="Navn" title="Giv retur-r√∏ret et unikt navn">
            </span>
        </td>
        <td><select class="form-select form-select-sm parent" title="V√¶lg hvilket retur-r√∏r, ventil eller Beholder dette r√∏r starter fra"></select></td>
        <td><select class="form-select form-select-sm material" title="V√¶lg r√∏rmateriale">
            <option value="Rustfri Press 316L">Rustfri Press 316L</option>
            <option value="Rustfri Svejse 316L">Rustfri Svejse 316L</option>
            <option value="Pex">Pex</option>
            <option value="Alupex">Alupex</option>
            <option value="PE100">PE100</option>
            <option value="Geberit Mepla">Geberit Mepla</option>
            <option value="Kobber">Kobber</option>
        </select></td>
        <td>
            <select class="form-select form-select-sm location" title="Placering (ift. varmetabsberegning)">
                <option value="heated" selected>Opvarmet rum</option>
                <option value="unheated">Uopvarmet rum</option>
                <option value="outside">Udend√∏rs</option>
            </select>
        </td>
        <td>
            <input type="text" class="form-control form-control-sm insulation-class" value="Auto" list="insulationClassOptions" title="V√¶lg isoleringsklasse (Auto baseres p√• placering og DS 452, Tabel 6.4)">
        </td>
        <td>
            <input type="text" class="form-control form-control-sm dim-input dim" value="16" title="Nominel diameter (mm)" list="">
            <datalist id=""></datalist>
        </td>
        <td><input type="number" min="0" class="form-control form-control-sm len" value="10" title="L√¶ngde (m)"></td>
        <td><input type="number" min="0" class="form-control form-control-sm fittings" value="0" title="Sum af enkeltmodstande (zeta)"></td>
        <td><button class="btn btn-sm btn-outline-danger" aria-label="Fjern retur-r√∏r" onclick="removeElement(this)">&times;</button></td>
    </tr>
</template>

<template id="customTapstedTemplate">
    <div class="input-group input-group-sm mb-2">
        <span class="input-group-text" data-key=""></span>
        <input type="number" min="0" step="0.01" class="form-control qf" value="" title="Normvandstr√∏m (qf) i l/s">
        <div class="input-group-text"><input type="checkbox" class="form-check-input is-apartment" title="Lejlighed? (Vigtigt for Beholder Metode A)"></div>
        <button class="btn btn-sm btn-outline-danger" onclick="removeCustomTapsted(this)" title="Fjern brugerdefineret tapsted">&times;</button>
    </div>
</template>

<template id="valveTRTemplate">
     <tr data-type="valve">
        <td>
            <span class="input-group input-group-sm">
                <span class="input-group-text">
                    <svg width="14" height="14" fill="currentColor" class="bi bi-diamond-fill" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M6.175.435a.636.636 0 0 1 .634-.14L8 1.442l1.191-.987a.636.636 0 0 1 .634.141l4.695 3.886a.636.636 0 0 1 .14.634l-.987 1.191 1.442.825a.636.636 0 0 1 .14.634l-3.886 4.695a.636.636 0 0 1-.634.14l-1.191-.987-1.191.987a.636.636 0 0 1-.634-.14l-4.695-3.886a.636.636 0 0 1-.14-.634l.987-1.191-1.442-.825a.636.636 0 0 1-.14-.634L6.175.435z"/></svg>
                    <span class="id-text ms-2"></span>
                </span>
                <input type="text" class="form-control name-input d-none name-text" placeholder="Navn" title="Giv ventilen et unikt navn">
            </span>
        </td>
        <td><select class="form-select form-select-sm parent" aria-label="For√¶lder node" title="V√¶lg hvilket retur-r√∏r, ventil eller Beholder denne ventil starter fra"></select></td>
        <td>
            <select class="form-select form-select-sm valve-type-select" title="V√¶lg ventiltype"></select>
        </td>
        <td><span class="form-control-plaintext form-control-sm ms-2">-</span></td>
        <td><span class="form-control-plaintext form-control-sm ms-2">-</span></td> <td><span class="form-control-plaintext form-control-sm ms-2">-</span></td>
        <td><span class="form-control-plaintext form-control-sm ms-2">-</span></td>
        <td><span class="form-control-plaintext form-control-sm ms-2">-</span></td>
        <td><button class="btn btn-sm btn-outline-danger" aria-label="Fjern element" onclick="removeElement(this)">&times;</button></td>
    </tr>
</template>

<script>
// --- KONSTANTER OG DATA ---

// Standard Tapsteder (ST) med normvandstr√∏m (qf) i l/s jf. DS 439:2024
// Struktur: { qf_hot: Varmt, qf_cold: Koldt, mode: 'both'|'cold_only'|'hot_only' }
const ST = { 
    "Lejlighed (standard)": { qf_hot: 0.8, qf_cold: 0.8, mode: 'both' },
    "H√•ndvask":             { qf_hot: 0.1, qf_cold: 0.1, mode: 'both' },
    "Brusebad":             { qf_hot: 0.15, qf_cold: 0.15, mode: 'both' },
    "K√∏kkenvask":           { qf_hot: 0.2, qf_cold: 0.2, mode: 'both' },
    "Vaskemaskine":         { qf_hot: 0.0, qf_cold: 0.2, mode: 'cold_only' }, // Koldt som standard i DK
    "Opvaskemaskine":       { qf_hot: 0.2, qf_cold: 0.2, mode: 'both' },      // Kan ofte tilsluttes varmt
    "Badekar":              { qf_hot: 0.3, qf_cold: 0.3, mode: 'both' },
    "Slangevinde":          { qf_hot: 0.0, qf_cold: 0.33, mode: 'cold_only' },
    "Reng√∏ringsvask":       { qf_hot: 0.2, qf_cold: 0.2, mode: 'both' },
    "Udslagsvask":          { qf_hot: 0.2, qf_cold: 0.2, mode: 'both' },
    "Spulehane":            { qf_hot: 0.2, qf_cold: 0.2, mode: 'both' },
    
    // KUN KOLDT VAND
    "WC":                   { qf_hot: 0.0, qf_cold: 0.1, mode: 'cold_only' },
    "Urinal":               { qf_hot: 0.0, qf_cold: 0.4, mode: 'cold_only' },
    "Udvendig Hane":        { qf_hot: 0.0, qf_cold: 0.2, mode: 'cold_only' }
};

// Forkortelser til diagrammet (Branchestandard)
const TAP_ABBREVIATIONS = {
    "Lejlighed (standard)": "LEJL", "H√•ndvask": "HV", "Brusebad": "BRUS", "K√∏kkenvask": "KV", 
    "Vaskemaskine": "VM", "Opvaskemaskine": "OM", "Badekar": "KAR", "Slangevinde": "SV", 
    "Reng√∏ringsvask": "RV", "Udslagsvask": "UV", "Spulehane": "SH", "WC": "WC", 
    "Urinal": "UR", "Udvendig Hane": "UH" 
};

// =================================================================================
// == R√òR-SERIER: DEFINITION AF RUHED (RH) i mm                                 ==
// V√¶rdier er baseret p√• DS 439:2024 (6.3.5.4) og brugerdata.
// Metaller regnes med afs√¶tning (0.15 mm), plast regnes uden (0.007-0.01 mm).
// =================================================================================
const RH = {
    "Kobber": 0.15,
    "Rustfri Press 316L": 0.15,
    "Rustfri Svejse 316L": 0.15,
    "Pex": 0.01,
    "Alupex": 0.007,
    "PE100": 0.01,
    "Geberit Mepla": 0.007
};

// =================================================================================
// == R√òR-SERIER: DEFINITION AF INDVENDIGE DIAMETRE (ID) i mm                     ==
// Format: "Materialenavn": { Nominel_Ydre_Diameter: Indre_Diameter, ... }
// Data er fra brugerinput.
// =================================================================================
const ID = {
    "Kobber": { 6: 4.4, 8: 6.4, 10: 8.4, 12: 10.0, 15: 13.0, 18: 16.0, 22: 20.0, 28: 25.6, 35: 32.0, 42: 39.0, 54: 51.0 },
    "Rustfri Press 316L": { 12: 10.0, 15: 13.0, 18: 16.0, 22: 19.6, 28: 25.6, 35: 32.0, 42: 39.0, 54: 51.0, 76.1: 72.1, 88.9: 84.9, 108: 104.0 },
    "Rustfri Svejse 316L": { 6: 4.0, 8: 6.0, 10: 8.0, 12: 10.0, 13.5: 8.9, 14: 12.0, 15: 13.0, 16: 14.0, 17.2: 14.0, 18: 16.0, 20: 18.0, 21.3: 17.3, 22: 20.0, 25: 22.0, 26.9: 22.9, 28: 25.0, 30: 27.0, 33.7: 29.7, 35: 31.0, 38: 35.0, 40: 36.0, 42.4: 38.4, 43: 40.0, 44.5: 40.5, 48.3: 44.3, 51: 47.0, 53: 50.0, 54: 50.0, 60.3: 56.3, 76.1: 68.9, 88.9: 80.9 },
    "Pex": { 10: 6.4, 12: 8.0, 15: 10.0, 18: 13.0, 22: 16.0, 28: 20.0, 32: 23.2, 40: 29.0, 50: 36.2, 63: 45.6, 75: 54.4, 90: 65.4, 110: 79.8 },
    "Alupex": { 16: 12.0, 20: 15.5, 25: 20.0, 32: 26.0, 40: 32.0, 50: 41.0, 63: 51.0 },
    "PE100": { 63: 55.4, 75: 66.0, 90: 79.2, 110: 96.8, 125: 110.2, 160: 141.0, 200: 176.2, 225: 198.2, 250: 220.4, 315: 277.6, 400: 352.6 },
    "Geberit Mepla": { 16: 11.5, 20: 15.0, 26: 20.0, 32: 26.0, 40: 33.0, 50: 42.0, 63: 54.0, 75: 65.8 }
};

// =================================================================================
// == VENTILTYPER                                                                 ==
// Her kan du tilf√∏je nye ventiltyper. Hver type skal have et unikt navn, ventil type (‚Äòdynamic‚Äô eller 'static')
// en 'data'-tabel, der f√∏lger samme format som Frese-ventilen.
// =================================================================================

// Data fra IMI STAD-D Datablad
const STATIC_VALVE_DATA = {
    "IMI STAD-D": [
        { dn: 10, kvs: 1.36, kv_2_5: 0.461, vvs: '406961-103' },
        { dn: 15, kvs: 2.56, kv_2_5: 0.931, vvs: '406961-104' },
        { dn: 20, kvs: 5.39, kv_2_5: 2.71,  vvs: '406961-106' },
        { dn: 25, kvs: 8.59, kv_2_5: 5.26,  vvs: '406961-108' },
        { dn: 32, kvs: 14.2, kv_2_5: 7.77,  vvs: '406961-110' },
        { dn: 40, kvs: 19.3, kv_2_5: 9.16,  vvs: '406961-111' },
        { dn: 50, kvs: 32.3, kv_2_5: 15.8,  vvs: '406961-112' }
    ]
};

const VALVE_TYPES = {
    // Data fra Frese Alpha sanitary Datablad
    "Frese ALPHA Sanitary": {
        type: 'dynamic',
        data: [
            // minDp = DeltaDP (Minimums differenstryk for at ventilen virker)
            { valveName: '47-20120', vvsNr: '406782.020', maxFlowLH: 20, minDp: 9000 },
            { valveName: '47-20170', vvsNr: '406782.040', maxFlowLH: 40, minDp: 9000 },
            { valveName: '47-20200', vvsNr: '406782.060', maxFlowLH: 60, minDp: 12000 },
            { valveName: '47-20230', vvsNr: '406782.080', maxFlowLH: 80, minDp: 13000 },
            { valveName: '47-20260', vvsNr: '406782.105', maxFlowLH: 105, minDp: 14000 },
            { valveName: '47-20300', vvsNr: '406782.135', maxFlowLH: 135, minDp: 14000 },
            { valveName: '47-20350', vvsNr: '406782.180', maxFlowLH: 180, minDp: 14000 },
            { valveName: '47-20400', vvsNr: '406782.240', maxFlowLH: 240, minDp: 14000 },
            { valveName: '47-20460', vvsNr: '406782.310', maxFlowLH: 310, minDp: 14000 },
            { valveName: '47-20510', vvsNr: '406782.410', maxFlowLH: 410, minDp: 15000 },
            { valveName: '47-20530', vvsNr: '406782.450', maxFlowLH: 450, minDp: 16000 },
            { valveName: '47-20570', vvsNr: '406782.500', maxFlowLH: 500, minDp: 17000 },
            { valveName: '47-20590', vvsNr: '406782.550', maxFlowLH: 550, minDp: 18000 },
            { valveName: '47-20620', vvsNr: '406782.600', maxFlowLH: 600, minDp: 19000 },
            { valveName: '47-20680', vvsNr: '406782.700', maxFlowLH: 700, minDp: 20000 },
            { valveName: '47-20740', vvsNr: '406782.800', maxFlowLH: 800, minDp: 20000 }
        ]
    },
    "IMI STAD-D": {
        type: 'static',
        data: STATIC_VALVE_DATA["IMI STAD-D"]
    }
};

// Data fra DS 452: N√∏dvendig tykkelse [mm] for Klasse 6 ved Œª=0.037 W/mK
const DS452_THICKNESS = { 15: 40, 18: 40, 22: 50, 28: 50, 35: 50, 42: 50, 54: 60, 76: 60 };
// NY KONSTANT: Standard handelstykkelser for isolering (i mm)
const STANDARD_INSULATION_THICKNESS = [10, 20, 30, 40, 50, 60, 70, 80, 100];
// Justeringsfaktorer baseret p√• placering. V√¶rdier er vejledende.
const DS452_ADJUSTMENT = { "heated": 1.0, "unheated": 1.2, "outside": 1.2 };

// =============================================================================
// == FYSISKE KONSTANTER & FUNKTIONER (Temperaturafh√¶ngige)                   ==
// =============================================================================
const G = 9.82; // Tyngdeacceleration (m/s¬≤)

/**
 * Beregner vandets densitet (rho) [kg/m¬≥] som funktion af temperatur [¬∞C].
 * Baseret p√• Tanaka's formel (standard for vand 0-100¬∞C).
 */
function getWaterDensity(t) {
    // Simpel men pr√¶cis approksimation (maks fejl 0.001% i omr√•det 0-100¬∞C)
    if (t < 0) t = 0; 
    if (t > 100) t = 100;
    return 1000 * (1 - Math.pow((t + 288.9414) / (508929.2 * (t + 68.12963)), 1) * Math.pow(t - 3.9863, 2));
}

/**
 * Beregner vandets dynamiske viskositet (mu) [Pa¬∑s] som funktion af temperatur [¬∞C].
 * Baseret p√• Vogel-Fulcher-Tammann ligningen.
 */
function getWaterViscosity(t) {
    if (t < 0) t = 0;
    // Resultat i Pa¬∑s (N¬∑s/m¬≤).  Eks: 20¬∞C -> 0.001002 Pa¬∑s
    return 0.00002414 * Math.pow(10, 247.8 / (t + 273.15 - 140));
}

/**
 * Beregner vandets specifikke varmekapacitet (cp) [J/(kg¬∑K)] som funktion af temperatur [¬∞C].
 * Vand er ret stabilt omkring 4180-4200, men vi tager det med for pr√¶cision.
 */
function getWaterSpecificHeat(t) {
    // Polynomisk tiln√¶rmelse (4180 J/kgK ved 20¬∞C, stiger let ved h√∏jere temp)
    return 4217.4 - 3.72 * t + 0.141 * Math.pow(t, 2) - 0.0026 * Math.pow(t, 3);
}

/**
 * Hj√¶lper: Beregner varmekapacitets-faktor (rho * cp) [J/(m¬≥¬∑K)] for en given temp.
 * Bruges til flow-beregninger.
 */
function getHeatCapacityFactor(t) {
    return getWaterDensity(t) * getWaterSpecificHeat(t); // Resultat ca. 4.120.000 - 4.180.000
}

const state = { sC: 0, rC: 0, tC: 0, nodes: [{id: "Beholder", type: "beholder"}], links: [], sim: null, reparentingNode: null, connectingNodeInfo: null, selectedNodes: new Set(), lastModel: null, lastConfig: null, useNames: false, customTapsteder: {}, names: new Map(), clipboard: null, movingBranch: null };

// Global "Dirty Flag" til auto-gem
let projektEr√Ündret = false;

const gridSize = 10;

document.addEventListener('DOMContentLoaded', () => {
    // 1. INITIALISER DIAGRAMMET F√òRST (S√• det er klar til data)
    initDiagram();

    // 2. Initialiser Popovers
    const popoverTriggerList = document.querySelectorAll('[data-bs-toggle="popover"]');
    [...popoverTriggerList].map(popoverTriggerEl => new bootstrap.Popover(popoverTriggerEl, {
        trigger: 'hover focus'
    }));

    // 3. TJEK FOR AUTO-GEM
    let autoSaveData = null;
    try {
        autoSaveData = localStorage.getItem('varmtBrugsvandAutoSave');
    } catch (err) {
        console.error("Kunne ikke l√¶se fra localStorage:", err);
    }

    let projectLoaded = false;

    if (autoSaveData) {
        if (confirm("Vi fandt et auto-gemt projekt. Vil du gendanne det?\n\n[OK] = Gendan\n[Annuller] = Start et nyt projekt (sletter auto-gem)")) {
            try {
                const data = JSON.parse(autoSaveData);
                loadProjectData(data); // Nu virker dette, fordi diagrammet er klar
                projectLoaded = true;
                console.log("Auto-gemt projekt er gendannet.");
            } catch (err) {
                alert("Fejl: Kunne ikke gendanne auto-gemt projekt. Starter et nyt projekt.");
                localStorage.removeItem('varmtBrugsvandAutoSave');
            }
        } else {
            localStorage.removeItem('varmtBrugsvandAutoSave');
            console.log("Auto-gem er slettet af brugeren.");
        }
    }
    
        // 4. HVIS INTET PROJEKT BLEV INDL√ÜST -> OPRET STANDARD PROJEKT
        if (!projectLoaded) {
        addStreng_vv();
        const btnRor = document.querySelector('.streng-card .btn-outline-secondary:last-of-type');
        addRorSektion(btnRor, 'ror_vv'); 
        addTapsted(btnRor);
        addCirkulationRor();
        
        // S√¶t standard-forbindelser
        updateAllSelects(); // Opdater lister f√∏rst
        
        const startSelect = document.querySelector('.circ-start');
        const endSelect = document.querySelector('.circ-end');
        if(startSelect && startSelect.options.length > 0) startSelect.value = startSelect.options[0].value;
        if(endSelect && endSelect.options.length > 0) endSelect.value = endSelect.options[0].value;
        
        // Opdater igen for at gemme forbindelserne
        updateAllSelects();
    }
    
    toggleAutoDim(document.getElementById('autoDimToggle').checked);

    // === TRIN 3: OPS√ÜTNING AF AUTO-GEM TRRIGGERS ===
    
    // 1. Generelle lyttere (Event Delegation)
    const accordion = document.getElementById('inputAccordion');
    if (accordion) {
        accordion.addEventListener('input', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') setProjektEr√Ündret();
        });
        accordion.addEventListener('change', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') setProjektEr√Ündret();
        });
        accordion.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' && (e.target.textContent.includes('+') || e.target.textContent.includes('√ó'))) {
                setProjektEr√Ündret();
            }
        });
    }
    
    // 2. Interval-Gem (5 minutter)
    setInterval(checkAndAutoSave, 300000); 

    // 3. Panik-Gem (ved luk/reload)
    window.addEventListener('beforeunload', (event) => {
        if (projektEr√Ündret) {
            console.log("Gemmer ulagrede √¶ndringer f√∏r siden lukkes...");
            autoSaveProject(); // Vi gemmer stadig for en sikkerheds skyld
            
            // GENAKTIVERET: Vis standard browser-advarsel
            event.preventDefault(); 
            event.returnValue = ''; 
        }
    });
});
	
// --- UI FUNKTIONER ---
function handleInputChange(e) {
    // Tjekker om √¶ndringen skete i en dropdown for tapstedstyper
    if (e.target.classList.contains('tapType')) {
        const tr = e.target.closest('tr');
        const selectedOption = e.target.options[e.target.selectedIndex];
        const typeName = selectedOption.text; // Navnet, fx "H√•ndvask"
        
        // Sl√• op i vores data (ST eller custom)
        let data = ST[typeName] || state.customTapsteder[typeName];
        
        // Fallback hvis data mangler (sikkerhed)
        if (!data) {
            // Pr√∏v at bruge value fra option som fallback flow
            data = { qf_hot: parseFloat(selectedOption.value) || 0 };
        }

        // Opdater qf-inputfeltet (Lige nu bruger vi Varmt flow som standard)
        const qfInput = tr.querySelector('.qf');
        if (qfInput) {
            qfInput.value = data.qf_hot;
        }
        
        // Opdater isApartment
        const isApartment = selectedOption.dataset.isApartment === 'true';
        tr.dataset.isApartment = isApartment;

        // Opdater noden i state
        const nodeId = tr.dataset.id;
        const node = state.nodes.find(n => n.id === nodeId);
        if (node) {
            node.tapType = typeName;
            updateDiagram(); 
        }
        
        if (document.getElementById('metodeA').checked) {
            toggleBeholderMetode(); 
        }
    }
    
    if (e.target.classList.contains('name-text')) {
        updateAllSelects();
    }
    
    if (typeof setProjektEr√Ündret === 'function') {
        setProjektEr√Ündret();
    }
}



function toggleGlobalOptimizationInputs() {
    const principle = document.getElementById('dimPrinciple').value;
    // Vis kun de ekstra radio-knapper, n√•r global optimering er valgt
    if (principle === 'global_pressure') {
        document.getElementById('globalInputs').style.display = 'block';
    } else {
        document.getElementById('globalInputs').style.display = 'none';
    }
}

// Funktion til at h√•ndtere skift af r√∏rmateriale
function handleMaterialChange(e) {
    const materialSelect = e.target;
    const newMaterial = materialSelect.value;
    const container = materialSelect.closest('[data-id]');
    const dimInput = container.querySelector('.dim');
    
    if (!dimInput) return;

    const currentDim = dimInput.value;
    const availableDims = Object.keys(ID[newMaterial]).map(Number);

    // Tjek om den nuv√¶rende dimension er gyldig for det nye materiale
    if (!availableDims.includes(Number(currentDim))) {
        // Hvis ikke, v√¶lg den f√∏rste tilg√¶ngelige dimension som standard
        dimInput.value = availableDims[0];
    }
}

// NY HJ√ÜLPEFUNKTION til at opdatere datalist for dimensioner
function updateDimOptions(materialSelectElement) {
    const tr = materialSelectElement.closest('tr');
    if (!tr) return;
    
    const datalist = tr.querySelector('datalist');
    const dimInput = tr.querySelector('.dim-input');
    if (!datalist || !dimInput) return;

    const material = materialSelectElement.value;
    const availableDims = Object.keys(ID[material] || {});
    
    // Opdater datalist-optionerne
    datalist.innerHTML = availableDims.map(d => `<option value="${d}"></option>`).join('');
    
    // Tjek om den nuv√¶rende dimension er gyldig
    const currentDim = dimInput.value;
    if (!availableDims.includes(currentDim)) {
        // Hvis ikke, v√¶lg den f√∏rste tilg√¶ngelige
        dimInput.value = availableDims[0] || '';
    }
}

// Opdater `handleMaterialChange` til at bruge den nye hj√¶lpefunktion
function handleMaterialChange(e) {
    updateDimOptions(e.target);
}
	
function addStreng_vv() {
    state.sC++;
    const id = `S${state.sC}`;
    const clone = document.getElementById('strengTemplate').content.cloneNode(true);
    const card = clone.querySelector('.card');
    card.dataset.id = id;
    card.querySelector('.id-text').textContent = `VV-Streng ${id}`; 
    card.querySelector('.name-text').onchange = (e) => state.names.set(id, e.target.value);
    
    document.getElementById('strengeContainer').appendChild(clone);
    addRorSektion(card.querySelector('.btn-outline-secondary'), 'ror_vv');
}

function addCirkulationRor() {
    state.rC++;
    const id = `Cirk${state.rC}`;
    const clone = document.getElementById('returRorTRTemplate').content.cloneNode(true); 
    const tr = clone.querySelector('tr'); 
    tr.dataset.id = id;
    tr.dataset.type = 'cirkulation_vv';
    
    // S√¶t unikke ID'er til datalist
    const datalistId = `list-${id}`;
    const dimInput = tr.querySelector('.dim-input');
    const datalist = tr.querySelector('datalist');
    dimInput.setAttribute('list', datalistId);
    datalist.id = datalistId;

    tr.querySelector('.id-text').textContent = id;
    tr.querySelector('.name-text').onchange = (e) => state.names.set(id, e.target.value);
    
    const materialSelect = tr.querySelector('.material');
    materialSelect.onchange = handleMaterialChange;
    
    document.getElementById('returContainerBody').appendChild(clone); 
    
    // Initialiser datalist
    updateDimOptions(materialSelect);
    
    updateAllSelects();
}

/**
 * Opdeler et eksisterende r√∏r i flere segmenter.
 * Inds√¶tter nye r√∏r f√∏r det valgte r√∏r for at bevare nedstr√∏ms-strukturen.
 * Inkluderer beregning af koordinater for at placere nye noder p√¶nt p√• linjen.
 * Opdeler et r√∏r (b√•de freml√∏b og retur).
 */
function splitPipe(targetId, segments) {
    const targetRow = document.querySelector(`tr[data-id="${targetId}"]`);
    if (!targetRow) return;
    
    // Bestem typen (ror eller retur)
    const type = targetRow.dataset.type;
    if (type !== 'ror_vv' && type !== 'cirkulation_vv') {
        alert("Kun r√∏r kan opdeles.");
        return;
    }

    // --- TRIN A: BEREGN KOORDINATER ---
    const currentParentId = targetRow.querySelector('.parent').value;
    const startNode = state.nodes.find(n => n.id === currentParentId);
    const endNode = state.nodes.find(n => n.id === targetId);
    
    let startX = 0, startY = 0, endX = 0, endY = 0;
    let useCoords = false;

    if (startNode && endNode) {
        // Brug .fx/.fy hvis de er sat (l√•st), ellers .x/.y
        startX = (startNode.fx !== undefined && startNode.fx !== null) ? startNode.fx : startNode.x;
        startY = (startNode.fy !== undefined && startNode.fy !== null) ? startNode.fy : startNode.y;
        endX = (endNode.fx !== undefined && endNode.fx !== null) ? endNode.fx : endNode.x;
        endY = (endNode.fy !== undefined && endNode.fy !== null) ? endNode.fy : endNode.y;
        useCoords = true;
    }
    // ----------------------------------

    const originalLen = parseFloat(targetRow.querySelector('.len').value) || 0;
    const newLen = originalLen / segments;
    
    const material = targetRow.querySelector('.material').value;
    const location = targetRow.querySelector('.location').value;
    const dim = targetRow.querySelector('.dim').value;
    const insulation = targetRow.querySelector('.insulation-class').value;
    const fittings = 0; 

    let lastParentId = currentParentId;

    // 2. Opret N-1 nye r√∏r F√òR det oprindelige r√∏r
    for (let i = 1; i < segments; i++) {
        let newId;
        
        // GENERER KORREKT ID BASERET P√Ö TYPE
        if (type === 'ror_vv') {
            const sId = targetId.split('-')[0]; 
            state.tC++; 
            newId = `${sId}-R${state.tC}`;
        } else { // type === 'cirkulation_vv'
            state.rC++;
            newId = `Retur${state.rC}`;
        }
        
        const datalistId = `list-${newId}`;
        
        // --- TRIN B: KOORDINATER ---
        if (useCoords) {
            const ratio = i / segments;
            const newX = startX + (endX - startX) * ratio;
            const newY = startY + (endY - startY) * ratio;
            
            state.nodes.push({
                id: newId,
                fx: newX,
                fy: newY
            });
        }

        const tr = document.createElement('tr');
        tr.dataset.id = newId;
        tr.dataset.type = type; // S√¶t korrekt type
        
        // Byg HTML (Universel for b√•de ror og retur)
        tr.innerHTML = `
            <td>
                <span class="input-group input-group-sm">
                    <span class="input-group-text id-text">${newId}</span>
                    <input type="text" class="form-control name-input d-none name-text" placeholder="Navn" title="Navn">
                </span>
            </td>
            <td><select class="form-select form-select-sm parent" title="For√¶lder"></select></td>
            <td><select class="form-select form-select-sm material" title="Materiale">
                <option value="Kobber">Kobber</option><option value="Rustfri Press 316L">Rustfri Press 316L</option><option value="Rustfri Svejse 316L">Rustfri Svejse 316L</option>
                <option value="Pex">Pex</option><option value="Alupex">Alupex</option><option value="PE100">PE100</option><option value="Geberit Mepla">Geberit Mepla</option>
            </select></td>
            <td>
                <select class="form-select form-select-sm location" title="Placering">
                    <option value="heated">Opvarmet rum</option>
                    <option value="unheated">Uopvarmet rum</option>
                    <option value="outside">Udend√∏rs</option>
                </select>
            </td>
            <td><input type="text" class="form-control form-control-sm insulation-class" value="${insulation}" list="insulationClassOptions" title="Isol."></td>
            <td>
                <input type="text" class="form-control form-control-sm dim-input dim" value="${dim}" title="Dim" list="${datalistId}">
                <datalist id="${datalistId}"></datalist>
            </td>
            <td><input type="number" min="0" class="form-control form-control-sm len" value="${newLen.toFixed(2)}" title="L√¶ngde"></td>
            <td><input type="number" min="0" class="form-control form-control-sm fittings" value="${fittings}" title="Zeta"></td>
            <td><button class="btn btn-sm btn-outline-danger" onclick="removeElement(this)" title="Fjern" aria-label="Fjern element">&times;</button></td>
        `;

        tr.querySelector('.material').value = material;
        tr.querySelector('.location').value = location;
        
        tr.querySelector('.name-text').onchange = (e) => state.names.set(newId, e.target.value);
        const matSelect = tr.querySelector('.material');
        matSelect.onchange = handleMaterialChange;
        
        targetRow.parentNode.insertBefore(tr, targetRow);
        
        updateDimOptions(matSelect);

        const pSel = tr.querySelector('.parent');
        const tempOpt = document.createElement('option');
        tempOpt.value = lastParentId;
        tempOpt.text = lastParentId;
        pSel.add(tempOpt);
        pSel.value = lastParentId;

        lastParentId = newId;
    }

    targetRow.querySelector('.len').value = newLen.toFixed(2);
    
    const targetPSel = targetRow.querySelector('.parent');
    const tempOptTarget = document.createElement('option');
    tempOptTarget.value = lastParentId;
    tempOptTarget.text = lastParentId;
    targetPSel.add(tempOptTarget);
    targetPSel.value = lastParentId;

    updateAllSelects();
    setProjektEr√Ündret();
}

/**
 * Kopierer en hel gren (r√∏r + alle efterf√∏lgende komponenter) til udklipsholderen.
 * Kopierer gren med RELATIVE KOORDINATER.
 * Rettet: Kopierer kun freml√∏bs-komponenter (ror/tapsted), ignorerer retur-tilslutninger.
 * Kopierer gren og husker position relativt til for√¶lder.
 * Sikrer korrekt beregning af vektor til for√¶lder (ogs√• Beholder).
 * Kopierer gren (Freml√∏b ELLER Retur).
 * Inkluderer logik til at filtrere b√∏rn baseret p√• typen af gren.
 */
function copyBranch(rootId) {
    const rootNode = state.nodes.find(n => n.id === rootId);
    const rootRow = document.querySelector(`tr[data-id="${rootId}"]`);
    
    if (!rootNode || !rootRow) return;

    // Hent offset til for√¶lder
    const parentId = rootRow.querySelector('.parent').value;
    const parentNode = state.nodes.find(n => n.id === parentId);
    
    const getX = (n) => (n.fx !== undefined && n.fx !== null) ? n.fx : n.x;
    const getY = (n) => (n.fy !== undefined && n.fy !== null) ? n.fy : n.y;
    
    const rootX = getX(rootNode);
    const rootY = getY(rootNode);
    
    let parentOffsetX = 60; 
    let parentOffsetY = 60;
    
    if (parentNode) {
        parentOffsetX = rootX - getX(parentNode);
        parentOffsetY = rootY - getY(parentNode);
    }
    
    const scrapNode = (id) => {
        const row = document.querySelector(`tr[data-id="${id}"]`);
        if (!row) return null;
        
        const type = row.dataset.type;
        // Tillad nu ogs√• retur og valve
        if (!['ror_vv', 'tapsted', 'cirkulation_vv', 'valve'].includes(type)) return null;

        const node = state.nodes.find(n => n.id === id);
        const nX = getX(node);
        const nY = getY(node);
        const relX = nX - rootX;
        const relY = nY - rootY;

        const data = { 
            type: type, 
            children: [],
            relX: relX, 
            relY: relY
        };
        
        const nameInput = row.querySelector('.name-text');
        if (nameInput) data.name = nameInput.value;

        // Data udtr√¶kning
        if (type === 'ror_vv' || type === 'cirkulation_vv') {
            data.material = row.querySelector('.material').value;
            data.location = row.querySelector('.location').value;
            data.insulation = row.querySelector('.insulation-class').value;
            data.dim = row.querySelector('.dim').value;
            data.len = row.querySelector('.len').value;
            data.fittings = row.querySelector('.fittings').value;
        } else if (type === 'tapsted') {
            const tapSelect = row.querySelector('.tapType');
            data.tapType = tapSelect.options[tapSelect.selectedIndex].text;
            data.qf = row.querySelector('.qf').value;
            data.kote = row.querySelector('.kote').value;
            data.syst = row.querySelector('.syst').checked;
            data.isApartment = row.dataset.isApartment;
        } else if (type === 'valve') {
            const vSel = row.querySelector('.valve-type-select');
            data.valveType = vSel ? vSel.value : "";
        }

        // Find b√∏rn rekursivt
        document.querySelectorAll('.parent').forEach(select => {
            if (select.value === id) {
                const childRow = select.closest('tr');
                if (childRow) {
                    const childType = childRow.dataset.type;
                    
                    // LOGIK: Hvis vi er i en freml√∏bs-gren (ror/tapsted), kopier kun freml√∏b.
                    // Hvis vi er i en retur-gren (retur/valve), kopier kun retur.
                    // Dette forhindrer at vi "hopper" over i det andet netv√¶rk.
                    let shouldCopy = false;
                    if (['ror_vv', 'tapsted'].includes(type)) {
                        if (['ror_vv', 'tapsted'].includes(childType)) shouldCopy = true;
                    } else if (['cirkulation_vv', 'valve'].includes(type)) {
                        if (['cirkulation_vv', 'valve'].includes(childType)) shouldCopy = true;
                    }

                    if (shouldCopy) {
                        const childData = scrapNode(childRow.dataset.id);
                        if (childData) data.children.push(childData);
                    }
                }
            }
        });

        return data;
    };

    const tree = scrapNode(rootId);
    if (tree) {
        tree.parentOffsetX = parentOffsetX;
        tree.parentOffsetY = parentOffsetY;
        state.clipboard = tree;
        
        // Visuel feedback
        const btn = rootRow.querySelector('button');
        if (btn) {
            const origClass = btn.className;
            btn.className = 'btn btn-sm btn-success';
            setTimeout(() => { btn.className = origClass; }, 500);
        }
        console.log("Kopieret:", tree);
    }
}

/**
 * Inds√¶tter kopieret gren p√• den valgte destination.
 * Inds√¶tter gren med SAMME AFSTAND til ny for√¶lder.
 * Sikrer at alle egenskaber (isolering, kote m.m.) kopieres med.
 * mode = 'new' (Opret ny streng/sektion) eller 'current' (Inds√¶t i eksisterende streng).
 */
/**
 * OPDATERET FUNKTION (Fase 4): Inds√¶tter gren (Freml√∏b eller Retur).
 */
function pasteBranch(targetParentId, mode = 'current') {
    if (!state.clipboard) {
        alert("Intet at inds√¶tte.");
        return;
    }

    const targetNode = state.nodes.find(n => n.id === targetParentId);
    if (!targetNode) return;

    // TJEK KOMPATIBILITET
    const clipType = state.clipboard.type;
    const isReturnClip = ['cirkulation_vv', 'valve'].includes(clipType);
    const isSupplyClip = ['ror_vv', 'tapsted'].includes(clipType);
    const parentType = targetNode.type;

    let allowed = false;
    if (isSupplyClip && (parentType === 'ror_vv' || parentType === 'beholder')) allowed = true;
    if (isReturnClip && (parentType === 'cirkulation_vv' || parentType === 'valve' || parentType === 'beholder')) allowed = true;
    
    if (!allowed) {
        alert(`Kan ikke inds√¶tte ${clipType} p√• ${parentType}.`);
        return;
    }

    // Positionering
    const getX = (n) => (n.fx !== undefined && n.fx !== null) ? n.fx : n.x;
    const getY = (n) => (n.fy !== undefined && n.fy !== null) ? n.fy : n.y;
    const baseX = getX(targetNode);
    const baseY = getY(targetNode);
    const vecX = (state.clipboard.parentOffsetX !== undefined) ? state.clipboard.parentOffsetX : 60;
    const vecY = (state.clipboard.parentOffsetY !== undefined) ? state.clipboard.parentOffsetY : 60;
    const newRootX = baseX + vecX;
    const newRootY = baseY + vecY;

    // CONTAINER LOGIK
    let targetStringId = ""; 

    if (isSupplyClip) {
        if (mode === 'new') {
             addStreng_vv(); 
             const newCard = document.querySelector('.streng-card:last-child');
             targetStringId = newCard.dataset.id; 
             // Slet standard-r√∏r
             newCard.querySelectorAll('button[aria-label="Fjern element"]').forEach(btn => removeElement(btn));
        } else {
             if (parentType === 'beholder') { alert("P√• beholder skal du v√¶lge 'Ny streng'"); return; }
             const parts = targetParentId.split('-');
             if (parts.length > 0) targetStringId = parts[0];
        }
    }
    // Retur-netv√¶rk har kun √©n global container (#returContainerBody), s√• ingen streng-logik n√∏dvendig

    // REKURSIV BYGGER
    const buildNode = (nodeData, parentId) => {
        let newId;
        
        if (nodeData.type === 'ror_vv' || nodeData.type === 'tapsted') {
             state.tC++;
             newId = `${targetStringId}-${nodeData.type === 'ror_vv' ? 'R' : 'T'}${state.tC}`;
        } else if (nodeData.type === 'cirkulation_vv') {
             state.rC++;
             newId = `Retur${state.rC}`;
        } else if (nodeData.type === 'valve') {
             valveCounter++;
             newId = `V${valveCounter}`;
        }
        
        const datalistId = `list-${newId}`;
        
        const newFx = newRootX + (nodeData.relX || 0);
        const newFy = newRootY + (nodeData.relY || 0);
        state.nodes.push({ id: newId, fx: newFx, fy: newFy });

        const tr = document.createElement('tr');
        tr.dataset.id = newId;
        tr.dataset.type = nodeData.type;

        // GENERER HTML BASERET P√Ö TYPE
        if (nodeData.type === 'ror_vv') {
            tr.innerHTML = `
                <td><span class="input-group input-group-sm"><span class="input-group-text id-text">${newId}</span><input type="text" class="form-control name-input d-none name-text" placeholder="Navn" title="Navn"></span></td>
                <td><select class="form-select form-select-sm parent" title="For√¶lder"></select></td>
                <td><select class="form-select form-select-sm material" title="Materiale"><option value="Kobber">Kobber</option><option value="Rustfri Press 316L">Rustfri Press 316L</option><option value="Rustfri Svejse 316L">Rustfri Svejse 316L</option><option value="Pex">Pex</option><option value="Alupex">Alupex</option><option value="PE100">PE100</option><option value="Geberit Mepla">Geberit Mepla</option></select></td>
                <td><select class="form-select form-select-sm location" title="Placering"><option value="heated">Opvarmet rum</option><option value="unheated">Uopvarmet rum</option><option value="outside">Udend√∏rs</option></select></td>
                <td><input type="text" class="form-control form-control-sm insulation-class" list="insulationClassOptions" title="Isol."></td>
                <td><input type="text" class="form-control form-control-sm dim-input dim" title="Dim" list="${datalistId}"><datalist id="${datalistId}"></datalist></td>
                <td><input type="number" min="0" class="form-control form-control-sm len" title="L√¶ngde"></td>
                <td><input type="number" min="0" class="form-control form-control-sm fittings" title="Zeta"></td>
                <td><button class="btn btn-sm btn-outline-danger" onclick="removeElement(this)" title="Fjern" aria-label="Fjern element">&times;</button></td>
            `;
            // Inds√¶t data
            tr.querySelector('.material').value = nodeData.material;
            tr.querySelector('.location').value = nodeData.location;
            tr.querySelector('.insulation-class').value = nodeData.insulation;
            tr.querySelector('.len').value = nodeData.len;
            tr.querySelector('.fittings').value = nodeData.fittings;
            
            const matSelect = tr.querySelector('.material');
            matSelect.onchange = handleMaterialChange;
            updateDimOptions(matSelect);
            tr.querySelector('.dim').value = nodeData.dim;
            
            document.querySelector(`.streng-card[data-id="${targetStringId}"] .ror-container`).appendChild(tr);

        } else if (nodeData.type === 'tapsted') {
             let opts = ''; 
             Object.keys(ST).forEach(k => opts += `<option value="${ST[k]}" ${k.includes('Lejlighed') ? 'data-is-apartment="true"' : ''}>${k}</option>`);
             Object.entries(state.customTapsteder).forEach(([k, v]) => opts += `<option value="${v.qf}" data-is-apartment="${v.isApartment}">${k}</option>`);

             tr.innerHTML = `
                <td><span class="input-group input-group-sm"><span class="input-group-text id-text">${newId}</span><input type="text" class="form-control name-input d-none name-text" placeholder="Navn"></span></td>
                <td><select class="form-select form-select-sm parent" title="For√¶lder"></select></td>
                <td><select class="form-select form-select-sm tapType" onchange="handleInputChange(event)" title="Type">${opts}</select></td>
                <td><input type="number" class="form-control form-control-sm qf" min="0" step="0.01" title="qf"></td>
                <td><input type="number" class="form-control form-control-sm kote allow-negative" title="Kote"></td>
                <td class="text-center"><input type="checkbox" class="form-check-input syst" title="Syst."></td>
                <td><button class="btn btn-sm btn-outline-danger" onclick="removeElement(this)" title="Fjern" aria-label="Fjern element">&times;</button></td>
            `;
            const tapSelect = tr.querySelector('.tapType');
            let foundIdx = Array.from(tapSelect.options).findIndex(opt => opt.text === nodeData.tapType);
            if (foundIdx !== -1) tapSelect.selectedIndex = foundIdx;
            tr.querySelector('.qf').value = nodeData.qf;
            // Gem typen p√• selve state-noden, s√• diagrammet kan vise forkortelsen med det samme
            state.nodes[state.nodes.length - 1].tapType = nodeData.tapType;
            tr.querySelector('.kote').value = nodeData.kote;
            tr.querySelector('.syst').checked = nodeData.syst;
            tr.dataset.isApartment = nodeData.isApartment;
            
            document.querySelector(`.streng-card[data-id="${targetStringId}"] .tapsted-container`).appendChild(tr);

        } else if (nodeData.type === 'cirkulation_vv') {
            tr.innerHTML = `
                <td><span class="input-group input-group-sm"><span class="input-group-text id-text">${newId}</span><input type="text" class="form-control name-input d-none name-text" placeholder="Navn"></span></td>
                <td><select class="form-select form-select-sm parent" title="For√¶lder"></select></td>
                <td><select class="form-select form-select-sm material" title="Materiale"><option value="Kobber">Kobber</option><option value="Rustfri Press 316L">Rustfri Press 316L</option><option value="Rustfri Svejse 316L">Rustfri Svejse 316L</option><option value="Pex">Pex</option><option value="Alupex">Alupex</option><option value="PE100">PE100</option><option value="Geberit Mepla">Geberit Mepla</option></select></td>
                <td><select class="form-select form-select-sm location" title="Placering"><option value="heated">Opvarmet rum</option><option value="unheated">Uopvarmet rum</option><option value="outside">Udend√∏rs</option></select></td>
                <td><input type="text" class="form-control form-control-sm insulation-class" list="insulationClassOptions" title="Isol."></td>
                <td><input type="text" class="form-control form-control-sm dim-input dim" title="Dim" list="${datalistId}"><datalist id="${datalistId}"></datalist></td>
                <td><input type="number" min="0" class="form-control form-control-sm len" title="L√¶ngde"></td>
                <td><input type="number" min="0" class="form-control form-control-sm fittings" title="Zeta"></td>
                <td><button class="btn btn-sm btn-outline-danger" onclick="removeElement(this)" title="Fjern" aria-label="Fjern element">&times;</button></td>
            `;
            tr.querySelector('.material').value = nodeData.material;
            tr.querySelector('.location').value = nodeData.location;
            tr.querySelector('.insulation-class').value = nodeData.insulation;
            tr.querySelector('.len').value = nodeData.len;
            tr.querySelector('.fittings').value = nodeData.fittings;
            
            const matSelect = tr.querySelector('.material');
            matSelect.onchange = handleMaterialChange;
            updateDimOptions(matSelect);
            tr.querySelector('.dim').value = nodeData.dim;
            
            document.getElementById('returContainerBody').appendChild(tr);

        } else if (nodeData.type === 'valve') {
             tr.innerHTML = `
                <td><span class="input-group input-group-sm"><span class="input-group-text"><svg width="14" height="14" fill="currentColor" class="bi bi-diamond-fill" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M6.175.435a.636.636 0 0 1 .634-.14L8 1.442l1.191-.987a.636.636 0 0 1 .634.141l4.695 3.886a.636.636 0 0 1 .14.634l-.987 1.191 1.442.825a.636.636 0 0 1 .14.634l-3.886 4.695a.636.636 0 0 1-.634.14l-1.191-.987-1.191.987a.636.636 0 0 1-.634-.14l-4.695-3.886a.636.636 0 0 1-.14-.634l.987-1.191-1.442-.825a.636.636 0 0 1-.14-.634L6.175.435z"/></svg><span class="id-text ms-2">${newId} ...</span></span><input type="text" class="form-control name-input d-none name-text" placeholder="Navn"></span></td>
                <td><select class="form-select form-select-sm parent" title="For√¶lder"></select></td>
                <td><select class="form-select form-select-sm valve-type-select" title="V√¶lg ventiltype"></select></td>
                <td>-</td><td>-</td><td>-</td><td>-</td><td>-</td>
                <td><button class="btn btn-sm btn-outline-danger" onclick="removeElement(this)" title="Fjern" aria-label="Fjern element">&times;</button></td>
            `;
            
            const valveSelect = tr.querySelector('.valve-type-select');
            let vOpts = '<option value="" disabled>V√¶lg type...</option>';
            for (const typeName in VALVE_TYPES) vOpts += `<option value="${typeName}">${typeName}</option>`;
            valveSelect.innerHTML = vOpts;
            valveSelect.value = nodeData.valveType || "";
            
            valveSelect.onchange = (e) => {
                const newType = e.target.value;
                tr.dataset.valveType = newType;
                tr.querySelector('.id-text').textContent = `${newId} (${newType.substring(0, 10)}...)`;
            };
            tr.dataset.valveType = nodeData.valveType;
            tr.querySelector('.id-text').textContent = `${newId} (${(nodeData.valveType || "V√¶lg").substring(0, 10)}...)`;
            
            document.getElementById('returContainerBody').appendChild(tr);
        }
        
        if(nodeData.name) {
             state.names.set(newId, nodeData.name);
             tr.querySelector('.name-text').value = nodeData.name;
        }
        tr.querySelector('.name-text').onchange = (e) => state.names.set(newId, e.target.value);

        const pSel = tr.querySelector('.parent');
        const tempOpt = document.createElement('option');
        tempOpt.value = parentId;
        tempOpt.text = parentId;
        pSel.add(tempOpt);
        pSel.value = parentId;

        if (nodeData.children) nodeData.children.forEach(child => buildNode(child, newId));
    };

    buildNode(state.clipboard, targetParentId);
    updateAllSelects();
    setProjektEr√Ündret();
    if (typeof zoomToFit === 'function') setTimeout(zoomToFit, 100);
}

function addRorSektion(btn) {
    state.tC++;
    const sId = btn.closest('.card').dataset.id;
    const id = `${sId}-R${state.tC}`;
    const container = btn.closest('.card-body').querySelector('.ror-container');
    
    const tr = document.createElement('tr');
    tr.dataset.id = id;
    tr.dataset.type = 'ror_vv';
    
    const datalistId = `list-${id}`; // Unikt ID for datalist
    
    tr.innerHTML = `
        <td>
            <span class="input-group input-group-sm">
                <span class="input-group-text id-text">${id}</span>
                <input type="text" class="form-control name-input d-none name-text" placeholder="Navn" title="Giv komponenten et unikt navn">
            </span>
        </td>
        <td><select class="form-select form-select-sm parent" aria-label="For√¶lder node" title="V√¶lg for√¶lder-node (r√∏r eller Beholder)"></select></td>
        <td><select class="form-select form-select-sm material" aria-label="Materiale" title="V√¶lg r√∏rmateriale">
            <option value="Kobber">Kobber</option>
            <option value="Rustfri Press 316L">Rustfri Press 316L</option>
            <option value="Rustfri Svejse 316L">Rustfri Svejse 316L</option>
            <option value="Pex">Pex</option>
            <option value="Alupex">Alupex</option>
            <option value="PE100">PE100</option>
            <option value="Geberit Mepla">Geberit Mepla</option>
        </select></td>
        <td>
            <select class="form-select form-select-sm location" title="Placering (ift. varmetabsberegning)">
                <option value="heated" selected>Opvarmet rum</option>
                <option value="unheated">Uopvarmet rum</option>
                <option value="outside">Udend√∏rs</option>
            </select>
        </td>
        <td><input type="text" class="form-control form-control-sm insulation-class" value="Auto" list="insulationClassOptions" title="V√¶lg isoleringsklasse (Auto baseres p√• placering og DS 452, Tabel 6.4)"></td>
        <td>
            <input type="text" class="form-control form-control-sm dim-input dim" value="20" title="Nominel diameter (mm)" list="${datalistId}">
            <datalist id="${datalistId}"></datalist>
        </td>
        <td><input type="number" min="0" class="form-control form-control-sm len" value="10" title="L√¶ngde (m)" aria-label="L√¶ngde (m)"></td>
        <td><input type="number" min="0" class="form-control form-control-sm fittings" value="0" title="Sum af enkeltmodstande (zeta) for kun dette r√∏rsegment" aria-label="Sum af enkeltmodstande (zeta)"></td>
        <td><button class="btn btn-sm btn-outline-danger" aria-label="Fjern element" onclick="removeElement(this)" title="Fjern komponent">&times;</button></td>
    `;
    
    tr.querySelector('.name-text').onchange = (e) => state.names.set(id, e.target.value);
    const materialSelect = tr.querySelector('.material');
    materialSelect.onchange = handleMaterialChange;
    
    container.appendChild(tr);
    
    const pSel = tr.querySelector('.parent');
    const rorInStreng = container.querySelectorAll('[data-type="ror_vv"]');
    pSel.value = rorInStreng.length > 1 ? rorInStreng[rorInStreng.length - 2].dataset.id : 'Beholder';
    
    updateDimOptions(materialSelect);
    
    updateAllSelects();
}

function addTapsted(btn) {
    state.tC++;
    const sId = btn.closest('.card').dataset.id;
    const id = `${sId}-T${state.tC}`;
    const container = btn.closest('.card-body').querySelector('.tapsted-container');
    
    // Byg options-listen. Vi gemmer nu qf_hot som value for bagudkompatibilitet i input-feltet
    let opts = ''; 
    Object.keys(ST).forEach(k => {
        const isApt = k.includes('Lejlighed');
        // Vi s√¶tter qf_hot som value, s√• den nuv√¶rende logik virker
        opts += `<option value="${ST[k].qf_hot}" data-is-apartment="${isApt}">${k}</option>`;
    });
    
    // Tilf√∏j brugerdefinerede (hvis de findes)
    Object.entries(state.customTapsteder).forEach(([k, v]) => {
        opts += `<option value="${v.qf_hot}" data-is-apartment="${v.isApartment}">${k}</option>`;
    });

    const defaultType = "Lejlighed (standard)";
    const defaultQf = ST[defaultType].qf_hot;

    const tr = document.createElement('tr');
    tr.dataset.id = id;
    tr.dataset.type = 'tapsted';
    tr.dataset.isApartment = 'true'; 
    
    tr.innerHTML = `
        <td>
            <span class="input-group input-group-sm">
                <span class="input-group-text id-text">${id}</span>
                <input type="text" class="form-control name-input d-none name-text" placeholder="Navn" title="Giv komponenten et unikt navn">
            </span>
        </td>
        <td><select class="form-select form-select-sm parent" aria-label="For√¶lder node" title="V√¶lg for√¶lder-node"></select></td>
        <td><select class="form-select form-select-sm tapType" onchange="handleInputChange(event)" aria-label="Tapsted type" title="V√¶lg type af tapsted">${opts}</select></td>
        <td><input type="number" class="form-control form-control-sm qf" min="0" value="${defaultQf}" step="0.01" aria-label="Flow (l/s)" title="Normvandstr√∏m (qf)"></td>
        <td><input type="number" class="form-control form-control-sm kote allow-negative" value="0" title="Kote (m)" aria-label="Kote (m)"></td>
        <td class="text-center"><input type="checkbox" class="form-check-input syst" title="Systematisk brug" aria-label="Systematisk brug"></td>
        <td><button class="btn btn-sm btn-outline-danger" aria-label="Fjern element" onclick="removeElement(this)" title="Fjern komponent">&times;</button></td>
    `;
    
    // S√¶t dropdown til standardv√¶rdien
    const typeSelect = tr.querySelector('.tapType');
    // Find index for defaultType
    for (let i = 0; i < typeSelect.options.length; i++) {
        if (typeSelect.options[i].text === defaultType) {
            typeSelect.selectedIndex = i;
            break;
        }
    }

    tr.querySelector('.name-text').onchange = (e) => state.names.set(id, e.target.value);
    
    container.appendChild(tr);
    
    const pSel = tr.querySelector('.parent');
    const rorInStreng = btn.closest('.card-body').querySelectorAll('[data-type="ror_vv"]');
    if(rorInStreng.length > 0) pSel.value = rorInStreng[rorInStreng.length-1].dataset.id;
    
    // Opdater state-noden
    const newNode = state.nodes.find(n => n.id === id);
    if (newNode) newNode.tapType = defaultType;

    updateAllSelects();
}


let valveCounter = 0;
function addValve() {
    // Fjernet l√¶sning fra global selector
    valveCounter++;
    const id = `V${valveCounter}`;
    const clone = document.getElementById('valveTRTemplate').content.cloneNode(true); 
    const tr = clone.querySelector('tr'); 
    tr.dataset.id = id;
    
    const idText = tr.querySelector('.id-text');
    idText.textContent = id; // Viser kun ID indtil type er valgt
    
    // Udfyld den lokale dropdown med ventil-typer
    const valveSelect = tr.querySelector('.valve-type-select');
    let opts = '<option value="" selected disabled>V√¶lg type...</option>';
    for (const typeName in VALVE_TYPES) {
        opts += `<option value="${typeName}">${typeName}</option>`;
    }
    valveSelect.innerHTML = opts;

    // Tilf√∏j onchange handler
    valveSelect.onchange = (e) => {
        const newType = e.target.value;
        tr.dataset.valveType = newType;
        // Opdater ID-tekst til at inkludere den valgte type
        idText.textContent = `${id} (${newType.substring(0, 10)}...)`;
    };

    tr.querySelector('.name-input').onchange = (e) => state.names.set(id, e.target.value);
    document.getElementById('returContainerBody').appendChild(clone); 
    updateAllSelects();
}

function createInputElement(id, type) {
    const div = document.createElement('div');
    div.className = 'input-group input-group-sm mb-2'; div.dataset.id = id; div.dataset.type = type;
    // Tilf√∏jet title til name-input og parent-select
    div.innerHTML = `<span class="input-group-text"><span class="id-text">${id}</span><input type="text" class="name-input d-none name-text" placeholder="Navn" title="Giv komponenten et unikt navn"></span><select class="form-select parent" aria-label="For√¶lder node" title="V√¶lg for√¶lder-node (r√∏r eller Beholder)"></select>`;
    if (type === 'ror_vv') {
        div.innerHTML += `<select class="form-select material" aria-label="Materiale" title="V√¶lg r√∏rmateriale"><option>PEX</option><option>Kobber</option><option>Rustfri</option></select>
            <select class="form-select location" title="Placering (ift. varmetabsberegning)">
                <option value="heated" selected>Opvarmet rum</option>
                <option value="unheated">Uopvarmet rum</option>
                <option value="outside">Udend√∏rs</option>
            </select>
            <input type="number" min="0" class="form-control dim-input dim" value="20" title="Nominel diameter (mm)" aria-label="Nominel diameter (mm)">
            <input type="number" min="0" class="form-control len" value="10" title="L√¶ngde (m)" aria-label="L√¶ngde (m)">
            <input type="number" min="0" class="form-control fittings" value="0" title="Sum af enkeltmodstande (zeta) for kun dette r√∏rsegment" aria-label="Sum af enkeltmodstande (zeta)">`;
    }
    div.innerHTML += `<button class="btn btn-sm btn-outline-danger" aria-label="Fjern element" onclick="removeElement(this)" title="Fjern komponent">&times;</button>`;
    if (type === 'ror_vv') {
        div.querySelector('.material').onchange = handleMaterialChange;
    }
    return div;
}

function removeElement(btn) { 
    // Find det element, der skal fjernes (enten en tr, en div.retur-ror, en div[data-type=valve] or en .streng-card)
    const elementToRemove = btn.closest('tr[data-id], div[data-id], .streng-card');
    if (!elementToRemove) return;
    
    // Hent ID, hvis det findes
    const id = elementToRemove.dataset.id;
    if (id) {
        state.names.delete(id);
    }
    
    // Fjern elementet
    elementToRemove.remove(); 
    updateAllSelects(); 
}

function toggleAutoDim(isAuto) {
    document.getElementById('autoDimInputs').style.display = isAuto ? 'flex' : 'none';
    document.querySelectorAll('.dim-input').forEach(i => i.disabled = isAuto);
}

function updateAllSelects() {
    // 1. Find alle gyldige for√¶ldre-emner
    const freml√∏bR√∏r = Array.from(document.querySelectorAll('.ror-container > tr[data-id]'));
    const returKomponenter = Array.from(document.querySelectorAll('#returContainerBody > tr[data-id]')); 

    // 2. Byg option-strengene
    const freml√∏bOptions = '<option value="Beholder">Beholder</option>' + freml√∏bR√∏r.map(el => `<option value="${el.dataset.id}">${getDisplayName(el.dataset.id)}</option>`).join('');
    const returOptions = '<option value="">Ingen</option>' + returKomponenter.map(el => `<option value="${el.dataset.id}">${getDisplayName(el.dataset.id)}</option>`).join('');
    const returParentOptions = '<option value="Beholder">Beholder</option>' + returKomponenter.map(el => `<option value="${el.dataset.id}">${getDisplayName(el.dataset.id)}</option>`).join('');

    // 3. Opdater alle '.parent' dropdowns
    document.querySelectorAll('.parent').forEach(s => {
        const p = s.closest('[data-id]');
        if (!p) return; 
        
        const ownId = p.dataset.id;
        const val = s.value; 
        
        // S√¶t de korrekte valgmuligheder baseret p√• type
        if (p.dataset.type === 'cirkulation_vv' || p.dataset.type === 'valve') {
            s.innerHTML = returParentOptions;
        } else {
            s.innerHTML = freml√∏bOptions;
        }
        
        const ownOpt = s.querySelector(`option[value="${ownId}"]`); 
        if(ownOpt) ownOpt.remove();
        
        // --- NY ROBUST LOGIK ---
        // Pr√∏v at s√¶tte den gemte v√¶rdi
        s.value = val;
        // Tjek om v√¶rdien *faktisk blev sat*. 
        // Hvis 'val' ikke fandtes p√• den nye liste (f.eks. "S1-R1" fandtes ikke, da "S1-T2" blev tjekket),
        // vil s.value nu v√¶re "" (eller den f√∏rste option).
        // Vi tvinger den til 'Beholder', hvis den er tom.
        if (s.value === "") {
            s.value = "Beholder";
        }
        // --- SLUT P√Ö NY LOGIK ---
    });

    // 4. Opdater alle '.circ-end' (cirkulationskobling) dropdowns
    document.querySelectorAll('.streng-card').forEach(c => {
        const start = c.querySelector('.circ-start'); 
        const end = c.querySelector('.circ-end');
        const startVal = start.value, endVal = end.value;
        
        const rorInStreng = Array.from(c.querySelectorAll('.ror-container > tr[data-id]'));
        start.innerHTML = rorInStreng.map(el => `<option value="${el.dataset.id}">${getDisplayName(el.dataset.id)}</option>`).join('');
        
        end.innerHTML = returOptions; 
        
        start.value = startVal || (rorInStreng.length > 0 ? rorInStreng[rorInStreng.length-1].dataset.id : '');
        end.value = endVal || '';
    });
    
    // 5. Opdater diagram og navne-visning
    document.querySelectorAll('[data-id]').forEach(el => {
        const idText = el.querySelector('.id-text');
        const nameText = el.querySelector('.name-text');
        if (idText) {
            if (el.dataset.type === 'valve') {
                const type = el.dataset.valveType || "V√¶lg";
                idText.textContent = `${el.dataset.id} (${type.substring(0, 10)}...)`;
            } else if (!idText.textContent.includes(el.dataset.id)) { 
                idText.textContent = el.dataset.id;
            }
        }
        if (nameText) nameText.value = state.names.get(el.dataset.id) || '';
    });

    buildNetworkAndRender();
}

function getDisplayName(id) {
    if (state.useNames && state.names.has(id)) return state.names.get(id);
    return id;
}

function toggleDisplayNames(useNames) {
    state.useNames = useNames;
    document.querySelectorAll('.id-text').forEach(el => el.classList.toggle('d-none', useNames));
    document.querySelectorAll('.name-text').forEach(el => el.classList.toggle('d-none', !useNames));
    updateAllSelects();
}

function addCustomTapsted() {
    const name = document.getElementById('newTapName').value.trim();
    const qf = parseFloat(document.getElementById('newTapQf').value);
    const isApartment = document.getElementById('newTapApartment').checked;
    
    if (!name || isNaN(qf) || qf <= 0) return alert('Ugyldigt navn eller qf.');
    
    // Gem i den nye struktur (vi antager det er varmt vand brugeren indtaster lige nu)
    state.customTapsteder[name] = { 
        qf_hot: qf, 
        qf_cold: 0, // Default 0 indtil vi har UI til koldt
        mode: 'hot_only', // Antag hot_only for custom indtil videre
        isApartment: isApartment 
    };
    
    // Opdater UI listen over custom tapsteder
    const clone = document.getElementById('customTapstedTemplate').content.cloneNode(true);
    clone.querySelector('.input-group-text').dataset.key = name;
    clone.querySelector('.input-group-text').textContent = name;
    clone.querySelector('.qf').value = qf;
    clone.querySelector('.is-apartment').checked = isApartment;
    
    document.getElementById('customTapsteder').appendChild(clone);
    
    // Ryd felter
    document.getElementById('newTapName').value = '';
    document.getElementById('newTapQf').value = '';
    document.getElementById('newTapApartment').checked = false;
    
    updateTapstedOptions();
    setProjektEr√Ündret();
}

function removeCustomTapsted(btn) {
    const key = btn.closest('.input-group').querySelector('.input-group-text').dataset.key;
    // Slet fra customTapsteder (ST skal ikke r√∏res, da custom ligger separat nu)
    delete state.customTapsteder[key];
    btn.closest('.input-group').remove();
    updateTapstedOptions();
    setProjektEr√Ündret();
}

function removeCustomTapsted(btn) {
    const key = btn.closest('.input-group').querySelector('.input-group-text').dataset.key;
    delete ST[key];
    delete state.customTapsteder[key];
    btn.closest('.input-group').remove();
    updateTapstedOptions();
	setProjektEr√Ündret();
}

function updateTapstedOptions() {
    document.querySelectorAll('.tapType').forEach(select => {
        const currentVal = select.value; // Den nuv√¶rende valgte v√¶rdi (flowet)
        const currentText = select.options[select.selectedIndex]?.text; // Det nuv√¶rende navn

        let opts = '';
        
        // 1. Standard Tapsteder
        Object.keys(ST).forEach(k => {
            const isApt = k.includes('Lejlighed');
            opts += `<option value="${ST[k].qf_hot}" data-is-apartment="${isApt}">${k}</option>`;
        });
        
        // 2. Custom Tapsteder
        Object.entries(state.customTapsteder).forEach(([k, v]) => {
            opts += `<option value="${v.qf_hot}" data-is-apartment="${v.isApartment}">${k}</option>`;
        });
        
        select.innerHTML = opts;
        
        // Pr√∏v at genskabe valget baseret p√• NAVN f√∏rst (mere sikkert nu)
        let foundIdx = -1;
        for(let i=0; i<select.options.length; i++) {
            if (select.options[i].text === currentText) {
                foundIdx = i;
                break;
            }
        }
        
        if (foundIdx !== -1) {
            select.selectedIndex = foundIdx;
        } else {
            // Fallback til v√¶rdi
            select.value = currentVal;
        }
    });
}


// --- DIAGRAM FUNKTIONER ---
function buildNetworkAndRender() {
    const oldNodes = new Map(state.nodes.map(n => [n.id, {fx: n.fx, fy: n.fy}]));
    state.nodes = [{id:"Beholder", type:"beholder", fx: oldNodes.get('Beholder')?.fx, fy: oldNodes.get('Beholder')?.fy}]; 
    state.links = [];
    
    const elements = document.querySelectorAll('.ror-container > tr[data-id], .tapsted-container > tr[data-id], #returContainerBody > tr[data-id]');
    
    elements.forEach(el => {
        const pos = oldNodes.get(el.dataset.id);
        state.nodes.push({id: el.dataset.id, type: el.dataset.type, fx: pos?.fx, fy: pos?.fy, displayName: getDisplayName(el.dataset.id)});
    });
    
    elements.forEach(el => {
        const p = el.querySelector('.parent')?.value; 
        // HER SKAL VI MAPPE TIL CSS KLASSER
        if(p) {
            let linkType = 'other';
            if (el.dataset.type === 'ror_vv' || el.dataset.type === 'tapsted') linkType = 'freml√∏b'; // R√∏d
            if (el.dataset.type === 'cirkulation_vv' || el.dataset.type === 'valve') linkType = 'cirkulation_vv'; // Stiplet R√∏d
            
            state.links.push({source: p, target: el.dataset.id, type: linkType});
        }
    });
    
    document.querySelectorAll('.streng-card').forEach(c => {
        const start = c.querySelector('.circ-start').value, end = c.querySelector('.circ-end').value;
        const zeta = parseFloat(c.querySelector('.circ-zeta').value) || 0;
        // Cirkulations-sl√∏jfen er altid retur/cirkulation
        if(start && end) state.links.push({source: start, target: end, type: 'cirkulation_vv', zeta: zeta});
    });
    updateDiagram();
}

/**
 * Opdaterer det visuelle udseende af noder baseret p√• den aktuelle markering.
 */
function updateSelectionVisuals() {
    d3.selectAll('.node').each(function(d) {
        d3.select(this).classed('selected', state.selectedNodes.has(d.id));
    });
}

function initDiagram() {
    const svg = d3.select("#diagram").append("svg");
    const width = svg.node().getBoundingClientRect().width;
    const height = svg.node().getBoundingClientRect().height;
    svg.attr("viewBox", `0 0 ${width} ${height}`);
    
    // Opret zoom-containeren √©n gang for alle her
    const container = svg.append("g").attr("class", "zoom-container");

    // Definer zoom-adf√¶rd
    const zoom = d3.zoom().on("zoom", (event) => {
        container.attr('transform', event.transform);
    });
    
    // Gem zoom-adf√¶rd og svg i state, s√• vi kan bruge dem i zoomToFit
    state.zoomBehavior = zoom;
    state.svgElement = svg;
    state.zoomContainer = container;

    svg.call(zoom);
    
    state.sim = d3.forceSimulation()
        .force("link", d3.forceLink().id(d => d.id).distance(60).strength(0.1))
        .force("charge", d3.forceManyBody().strength(-20))
        .force("collide", d3.forceCollide(20));
    
    state.nodes[0].fx = width / 2;
    state.nodes[0].fy = height / 2;

    updateDiagram();
}

function updateDiagram() {
    const svg = d3.select("#diagram svg");
    
    // S√∏rg for at zoom-containeren findes (oprettet i initDiagram), men t√∏m indholdet
    let container = svg.select(".zoom-container");
    if (container.empty()) {
        container = svg.append("g").attr("class", "zoom-container");
    }
    container.html(""); // Ryd gammelt indhold, men behold zoom/pan state

    // 1. TEGN LINJER (LINKS)
    // Klassenavnet bliver nu dynamisk: 'link-freml√∏b' eller 'link-cirkulation_vv'
    const link = container.append("g").selectAll("line")
        .data(state.links).join("line")
        .attr("class", d => `link-${d.type}`);

    // 2. TEGN TEKST P√Ö LINJER
    const linkText = container.append("g").selectAll("text")
        .data(state.links).join("text")
        .attr("class", "link-text")
        .attr("dy", -2);

    // 3. TEGN NODER (PUNKTER)
    const node = container.append("g").selectAll("g")
        .data(state.nodes, d => d.id).join("g")
        .attr("class", "node")
        .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended))
        .on('click', handleNodeClick)
        .on('contextmenu', handleNodeRightClick);

    // Tilf√∏j former og farver baseret p√• de nye typer
    node.each(function(d) {
        const group = d3.select(this);
        
        if (d.type === 'valve') {
            // Ventiler er lilla romber
            group.append('rect')
                .attr('width', 14).attr('height', 14)
                .attr('x', -7).attr('y', -7)
                .attr('transform', 'rotate(45)')
                .style('fill', '#6f42c1');
        } else {
            // Andre er cirkler
            group.append("circle")
                .attr("r", d => d.type === 'beholder' ? 10 : 5)
                .attr("fill", d => {
                    // NY NAVNGIVNINGS-LOGIK:
                    if (d.type === 'ror_vv') return '#dc3545';        // R√∏d (Varmt Frem)
                    if (d.type === 'cirkulation_vv') return '#a71d2a'; // M√∏rker√∏d (Varm Retur)
                    if (d.type === 'tapsted') return '#198754';        // Gr√∏n (Tapsted)
                    if (d.type === 'beholder') return '#343a40';       // M√∏rkegr√• (Beholder)
                    return '#6c757d'; // Fallback gr√•
                });
        }
    });
    
    // 4. TEKST LABELS P√Ö NODER
    node.append("text")
        .text(d => {
            let label = getDisplayName(d.id);
            
            // H√•ndter forkortelser for tapsteder (LEJL, BRUS, etc.)
            if (d.type === 'tapsted') {
                let typeName = d.tapType;
                
                // Fallback: Find type i DOM hvis den ikke er p√• data-objektet
                if (!typeName) {
                    const row = document.querySelector(`tr[data-id="${d.id}"]`);
                    if (row) {
                        const sel = row.querySelector('.tapType');
                        if (sel && sel.selectedIndex >= 0) typeName = sel.options[sel.selectedIndex].text;
                    }
                }

                if (typeName && TAP_ABBREVIATIONS[typeName]) {
                    label += ` (${TAP_ABBREVIATIONS[typeName]})`;
                }
            }
            return label;
        })
        .attr("dy", "-1em")
        .attr("font-size", "8px")
        .attr("text-anchor", "middle")
        .style("pointer-events", "none")
        .style("text-shadow", "0px 0px 3px white");

    // 5. OPDATER SIMULATION (TICK)
    state.sim.nodes(state.nodes).on("tick", () => {
        link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

        node
            .attr("transform", d => `translate(${d.x},${d.y})`);

        linkText
            .attr("x", d => (d.source.x + d.target.x) / 2)
            .attr("y", d => (d.source.y + d.target.y) / 2);
    });

    state.sim.force("link").links(state.links);
    state.sim.alpha(0.3).restart();

    updateSelectionVisuals();
    
    // Opdater r√∏rtykkelser og farver (hvis beregning er k√∏rt)
    if (state.lastModel) {
        updateDiagramStyles();
    }
}

/**
 * NY FUNKTION: Zoomer og panorerer s√• hele netv√¶rket er synligt.
 * Rettet til at bruge viewBox-koordinater for korrekt centrering.
 */
function zoomToFit() {
    if (!state.nodes || state.nodes.length === 0) return;
    if (!state.svgElement || !state.zoomBehavior) return;

    // 1. Find gr√¶nserne (bounding box) for alle noder
    const xExtent = d3.extent(state.nodes, d => d.x);
    const yExtent = d3.extent(state.nodes, d => d.y);
    
    if (xExtent[0] === undefined) return;

    // RETTELSE: Vi bruger viewBox dimensioner i stedet for clientWidth/Height.
    // Dette sikrer, at vi regner i det samme koordinatsystem som d3.zoom arbejder i.
    let width, height;
    const viewBoxAttr = state.svgElement.attr("viewBox");
    
    if (viewBoxAttr) {
        const vb = viewBoxAttr.split(" ").map(parseFloat);
        width = vb[2]; // viewBox width
        height = vb[3]; // viewBox height
    } else {
        // Fallback (b√∏r ikke ske med vores initDiagram)
        width = state.svgElement.node().clientWidth;
        height = state.svgElement.node().clientHeight;
    }

    const padding = 50; // Lidt ekstra luft rundt om

    // Beregn bredde og h√∏jde af selve netv√¶rket
    const dx = xExtent[1] - xExtent[0] + (padding * 2);
    const dy = yExtent[1] - yExtent[0] + (padding * 2);
    
    // Find midtpunktet af netv√¶rket (i graf-koordinater)
    const cx = (xExtent[0] + xExtent[1]) / 2;
    const cy = (yExtent[0] + yExtent[1]) / 2;

    // Beregn skala (hvor meget skal vi zoome ind/ud for at det passer i boksen)
    // Vi dividerer ViewBox-st√∏rrelse med Netv√¶rks-st√∏rrelse
    const scale = Math.min(width / dx, height / dy);
    
    // Begr√¶ns zoom (ikke for t√¶t p√•, ikke for langt v√¶k)
    const limitedScale = Math.min(2, Math.max(0.1, scale));

    // Beregn translationen for at centrere midtpunktet
    // Formel: (Halv sk√¶rmbredde) - (Halv netv√¶rksbredde * skala)
    // Eller mere pr√¶cist: Vi flytter grafens centrum (cx) til 0, scaler, og flytter derefter til midten af sk√¶rmen.
    const tx = (width / 2) - (cx * limitedScale);
    const ty = (height / 2) - (cy * limitedScale);

    // Udf√∏r zoom med en glidende overgang
    const transform = d3.zoomIdentity.translate(tx, ty).scale(limitedScale);
    state.svgElement.transition().duration(750).call(state.zoomBehavior.transform, transform);
}

// --- DRAG & DROP FUNKTIONER ---

function dragstarted(e, d) {
    if (!e.active) state.sim.alphaTarget(0.1).restart();
    // Shift-klik starter "reparenting" (flyt for√¶ldre)
    if (e.sourceEvent.shiftKey) { 
        state.reparentingNode = d; 
        d3.select(this).classed('reparenting', true); 
    }
}

function dragged(e, d) {
    // Flyt noden (l√•st til grid)
    d.fx = Math.round(e.x / gridSize) * gridSize;
    d.fy = Math.round(e.y / gridSize) * gridSize;
}

function dragended(e, d) {
    if (!e.active) state.sim.alphaTarget(0);
    
    // H√•ndter "reparenting" (hvis man slipper en node oven p√• en anden med Shift nede)
    if (state.reparentingNode) {
        d3.select(this).classed('reparenting', false);
        
        const svgNode = state.svgElement.node();
        const transform = d3.zoomTransform(svgNode);
        
        const [px, py] = d3.pointer(e.sourceEvent, svgNode);
        const x = transform.invertX(px);
        const y = transform.invertY(py);
        
        const targetNode = state.sim.find(x, y, 30);
        
        if (targetNode && targetNode.id !== state.reparentingNode.id) {
            // Find r√¶kken i tabellen for den node, vi flyttede
            const el = document.querySelector(`tr[data-id="${state.reparentingNode.id}"]`);
            if (el) {
                const pSel = el.querySelector('.parent');
                if (pSel) {
                    // Tjek om det er en gyldig for√¶lder (simpel validering)
                    // Vi lader updateAllSelects h√•ndtere den endelige logik, men vi s√¶tter v√¶rdien her
                    pSel.value = targetNode.id; 
                    updateAllSelects(); 
                }
            }
        }
        state.reparentingNode = null;
    }
    
    // VIGTIGT for Auto-gem: Fort√¶l systemet, at noget er √¶ndret (positionen)
    if (typeof setProjektEr√Ündret === 'function') {
        setProjektEr√Ündret();
    }
}
	
/**
 * Synkroniserer data fra den f√¶rdige beregningsmodel over til
 * det 'state'-objekt, som D3-diagrammet bruger til at tegne.
 * Dette sikrer, at tegnedata altid er opdateret med de seneste resultater.
 */
function syncModelToState(model) {
    const stateNodeMap = new Map(state.nodes.map(n => [n.id, n]));
    
    model.nodes.forEach((calculatedNode, id) => {
        const stateNode = stateNodeMap.get(id);
        if (stateNode) {
            // Kopier alle beregnede egenskaber over til state-noden
            Object.assign(stateNode, calculatedNode);
        }
    });

    // Gem ogs√• den fulde model til rapportering og andre funktioner
    state.lastModel = model;
}

function validateInputs(config) {
    const advarslerDiv = document.getElementById('advarsler');
    advarslerDiv.innerHTML = '';
    let valid = true;
    if (config.pln <= 0 || config.min_tap_tryk < 0 || config.T_v < 0 || config.T_omg < 0 || config.dT <= 0) {
        advarslerDiv.innerHTML += `<p class="alert alert-danger">Fejl: Forsyningstryk og ŒîT skal v√¶re positive, √∏vrige v√¶rdier m√• ikke v√¶re negative.</p>`;
        valid = false;
    }
    document.querySelectorAll('input[type="number"]').forEach(inp => {
        // Tjek kun felter, der IKKE har klassen 'allow-negative'
        if (!inp.classList.contains('allow-negative')) {
            if (parseFloat(inp.value) < parseFloat(inp.min || 0)) {
                // Brug .title eller .id for at give en mere specifik fejlmeddelelse
                advarslerDiv.innerHTML += `<p class="alert alert-danger">Fejl: ${inp.title || inp.id} m√• ikke v√¶re negativ.</p>`;
                valid = false;
            }
        }
    });
    document.querySelectorAll('.dim-input').forEach(inp => {
        if (!inp.disabled) { // Kun tjek manuelle dimensioner
            const material = inp.closest('[data-id]').querySelector('.material').value;
            const dim = parseFloat(inp.value);
            if (!ID[material][dim]) {
                advarslerDiv.innerHTML += `<p class="alert alert-danger">Fejl: Dimension ${dim} mm er ugyldig for ${material}.</p>`;
                valid = false;
            }
        }
    });
    return valid;
}

function getGlobalConfig() {
    // Hj√¶lper til sikker parsing
    const getVal = (id, def) => {
        const el = document.getElementById(id);
        const val = parseFloat(el ? el.value : def);
        return isNaN(val) ? def : val;
    };

    return {
        projectName: document.getElementById('projectName')?.value || '',
        pln: getVal('pln', 400000),
        min_tap_tryk: getVal('min_tap_tryk', 100000),
        T_v: getVal('T_v', 55),
        T_omg_inde: getVal('T_omg', 20),
        T_omg_ude: getVal('T_omg_ude', 5),
        dT: getVal('dT', 5),
        lambda: getVal('lambda', 0.037),
        
        // Her sikrer vi at till√¶ggene kommer med. Standard er 25% og 20% hvis feltet er tomt.
        fittings_pct: getVal('fittings_pct', 25), 
        heat_loss_pct: getVal('heat_loss_pct', 20),

        isAuto: document.getElementById('autoDimToggle')?.checked || false,
        dimPrinciple: document.getElementById('dimPrinciple')?.value || 'combined',
        max_dp_m: getVal('max_dp_m', 150),
        max_v_f: getVal('max_v_f', 1.5),
        min_v_f: getVal('min_v_f', 0.5),
        max_v_c: getVal('max_v_c', 1.5),
        forsyningens_kote: getVal('forsyningens_kote', 0)
    };
}

function buildModel(config) {
    const model = { tree: {id:'Beholder', children:[]}, nodes: new Map(), loops: [], isAuto: config.isAuto };
    model.nodes.set('Beholder', model.tree);

    // KORREKT SELECTOR: Vi leder nu efter de nye typer
    const selector = '.ror-container > tr[data-id], .tapsted-container > tr[data-id], #returContainerBody > tr[data-id]';
    
    document.querySelectorAll(selector).forEach(el => {
        const data = { 
            id: el.dataset.id, 
            type: el.dataset.type, // Her henter den nu 'ror_vv' eller 'cirkulation_vv'
            children: [], 
            parentId: el.querySelector('.parent')?.value, 
            name: state.names.get(el.dataset.id) || '' 
        };
        
        if (el.dataset.type === 'valve') {
            data.valveType = el.querySelector('.valve-type-select')?.value || el.dataset.valveType;
        }

        // Tjek for DE NYE navne
        if (data.type === 'ror_vv' || data.type === 'cirkulation_vv') {
            Object.assign(data, { 
                L: parseFloat(el.querySelector('.len')?.value) || 0, 
                zeta_sum: parseFloat(el.querySelector('.fittings')?.value) || 0, 
                material: el.querySelector('.material')?.value,
                location: el.querySelector('.location')?.value || 'heated',
                insulationClassSelection: el.querySelector('.insulation-class')?.value || 'Auto'
            });
            
            if (!config.isAuto) {
                data.nom_dim = parseFloat(el.querySelector('.dim')?.value) || 0;
            }
        }
        
        if (data.type === 'tapsted') {
            data.qf = parseFloat(el.querySelector('.qf')?.value) || 0;
            data.isSyst = el.querySelector('.syst')?.checked || false;
            data.isApartment = el.dataset.isApartment === 'true';
            data.kote = parseFloat(el.querySelector('.kote')?.value) || 0;
        }
        
        model.nodes.set(data.id, data);
    });

    model.nodes.forEach(n => { 
        if(n.parentId && model.nodes.has(n.parentId)) model.nodes.get(n.parentId).children.push(n); 
    });
    
    document.querySelectorAll('.streng-card').forEach(c => {
        const start = c.querySelector('.circ-start').value, end = c.querySelector('.circ-end').value;
        const zeta = parseFloat(c.querySelector('.circ-zeta').value) || 0;
        if(start && end) model.loops.push({ id: c.dataset.id, name: state.names.get(c.dataset.id) || '', startNodeId: start, endNodeId: end, zeta });
    });
    return model;
}



// OPDATERET FUNKTION: Beregner isoleringstykkelse dynamisk
function calculateInsulation(model, config) {
    const lambda = config.lambda; // f.eks. 0.037 W/mK
    
    model.nodes.forEach(n => {
        if ((n.type !== 'ror_vv' && n.type !== 'cirkulation_vv') || !n.nom_dim) return;

        // --- Trin A & B: Bestem Endelig Isoleringsklasse ---
        let autoKlasse = 0;
        
        if (n.type === 'cirkulation_vv') { // "Cirkulationsledning"
            autoKlasse = (n.location === 'heated') ? 4 : 6;
        } else if (n.type === 'ror_vv') { // "Fordelings-" eller "Koblingsledning"
            autoKlasse = (n.location === 'heated') ? 4 : 6;
        }

        let endeligKlasse = autoKlasse;
        if (n.insulationClassSelection && n.insulationClassSelection !== 'Auto') {
            endeligKlasse = parseInt(n.insulationClassSelection.replace('Kl. ', ''), 10) || 0;
        }
        
        n.insulationClass = endeligKlasse;
        
        // --- Trin C: Find U-v√¶rdi Krav (DS 452, Tabel 5.1) ---
        const Ul_constants = getInsulationClassUl(endeligKlasse);
        if (!Ul_constants) {
            n.insulationThickness = 0; 
            n.u_value_per_meter = 0; 
            return; 
        }

        const Dep_m = n.nom_dim / 1000; 
        const Ul_krav = (Ul_constants.A * Dep_m) + Ul_constants.B;
        
        // --- Trin D: Beregn N√∏dvendig Tykkelse (mm) ---
        const exp_val = Math.exp((2 * Math.PI * lambda) / Ul_krav);
        const tykkelse_m = (Dep_m * (exp_val - 1)) / 2;
        const tykkelse_mm = tykkelse_m * 1000;
        
        // --- Trin E: Gem V√¶rdier (Rund op til n√¶rmeste HANDELSST√òRRELSE) ---
        // OPDATERET LINJE: Bruger den nye hj√¶lpefunktion i stedet for "rund op til 5mm"
        n.insulationThickness = findNextStandardThickness(tykkelse_mm);

        // Beregn den *faktiske* U-v√¶rdi med den afrundede tykkelse (til 'calculateHeatLoss')
        const Di_isol_m = Dep_m;
        const Dy_isol_m = Dep_m + 2 * (n.insulationThickness / 1000);
        
        if (Dy_isol_m <= Di_isol_m) {
             n.u_value_per_meter = 0;
        } else {
             // U-v√¶rdi pr. meter [W/mK]. 1 / R_insulation
             const R_insulation = Math.log(Dy_isol_m / Di_isol_m) / (2 * Math.PI * lambda);
             n.u_value_per_meter = 1 / R_insulation;
        }
    });
}

// NY HJ√ÜLPEFUNKTION: Returnerer U-v√¶rdi formel-konstanter fra DS 452, Tabel 5.1
function getInsulationClassUl(klasse) {
    // DS 452, Tabel 5.1: Ul = A * Dep + B
    switch (klasse) {
        case 1: return { A: 3.3, B: 0.22 };
        case 2: return { A: 2.6, B: 0.20 };
        case 3: return { A: 2.0, B: 0.18 };
        case 4: return { A: 1.5, B: 0.16 };
        case 5: return { A: 1.1, B: 0.14 };
        case 6: return { A: 0.8, B: 0.12 };
        default: return null; // Klasse 0 eller ugyldig
    }
}

// NY HJ√ÜLPEFUNKTION: Finder den n√¶ste standard handelstykkelse
function findNextStandardThickness(calculated_mm) {
    if (calculated_mm <= 0) return 0;
    
    for (const standardSize of STANDARD_INSULATION_THICKNESS) {
        if (standardSize >= calculated_mm) {
            return standardSize; // Returner den f√∏rste standardst√∏rrelse, der er >= den beregnede
        }
    }
    // Hvis den beregnede tykkelse er st√∏rre end den st√∏rste i listen (f.eks. 120mm)
    return STANDARD_INSULATION_THICKNESS[STANDARD_INSULATION_THICKNESS.length - 1]; // Returner max-tykkelsen (100)
}

// FUNKTION BEREGN
function beregn() {
    const config = getGlobalConfig();
    if (!validateInputs(config)) return;
    
    let model;
    if (config.dimPrinciple === 'global_pressure') {
        document.getElementById('advarsler').innerHTML = `<p class="alert alert-info">K√∏rer global optimering (VV). Dette kan tage et √∏jeblik...</p>`;
        setTimeout(() => {
            model = beregnGlobalOptimering(config);
            finishCalculation(model, config);
        }, 50);
    } else {
        model = beregnStandard(config);
        finishCalculation(model, config);
    }
}

// Ny hj√¶lpefunktion til at afslutte beregningen
function finishCalculation(model, config) {
    if (!model) {
        document.getElementById('advarsler').innerHTML = `<p class="alert alert-danger">Beregningen fejlede.</p>`;
        return;
    }
    
    // VIGTIGT: Vi kalder nu den specifikke VV-funktion
    calculateTemperatures_VV(model, config);
    
    syncModelToState(model);
    state.lastConfig = config;
    
    // displayResults er generisk (indtil videre), da den bare viser data fra modellen
    displayResults(model, config);
    
    updateDiagram();
}

function validateCirculationLoops(model, advarslerDiv) {
    let isValid = true;
    model.loops.forEach(loop => {
        const valvesInLoop = loop.path.filter(id => model.nodes.get(id)?.type === 'valve');
        if (valvesInLoop.length === 0) {
            advarslerDiv.innerHTML += `<p class="alert alert-warning">Advarsel: Cirkulationsstreng "${getDisplayName(loop.id)}" mangler en cirkulationsventil.</p>`;
        }
        if (valvesInLoop.length > 1) {
            advarslerDiv.innerHTML += `<p class="alert alert-danger">Fejl: Cirkulationsstreng "${getDisplayName(loop.id)}" har mere end √©n ventil. Der m√• kun v√¶re √©n.</p>`;
            isValid = false;
        }
    });
    return isValid;
}


function beregnStandard(config) {
    const advarslerDiv = document.getElementById('advarsler');
    const model = buildModel(config);
    if (!model) return null;
    
    // 1. Beregn flow i freml√∏b (Spidslast) - VARMT VAND
    calculateQd_VV(model);
    
    // 2. Analyser systemet (find hovedr√∏r/grenr√∏r)
    model.loops.forEach(l => l.path = getPath(model, l.startNodeId, l.endNodeId));
    analyzeSystemTopology(model); 

    // 3. Dimensioner freml√∏b (hvis auto) - VARMT VAND
    if (config.isAuto) dimensionSupply_VV(model, config);
    
    // 4. Beregn tryktab i freml√∏b - VARMT VAND
    calculatePressureDrop_VV(model.tree, 'dp_tap', 'qd', config); 
    
    // 5. Find kritisk vej (til resttryk) - VARMT VAND
    const pressureDropResult = findMaxPathDp_VV(model.tree, config);
    model.max_dp_tapning = pressureDropResult.max_dp;
    model.criticalPath = new Set(pressureDropResult.path);
    
    // 6. CIRKULATIONS BEREGNING (Andelsprincippet + Fysik) - KUN relevant for VV
    // a. Beregn isolering
    calculateInsulation(model, config);
    
    // b. K√∏r den store cirkulations-motor
    calculateCirculationFlows_VV(model, config);
    
    // c. Opdater isolering og varmetab en sidste gang
    if (config.isAuto) {
        calculateInsulation(model, config);
        calculateHeatLoss_VV(model, config);
    }

    // 7. Validering og afslutning
    if (!validateCirculationLoops(model, advarslerDiv)) return null;
    
    calculateCirculationDP_VV(model, config);
    calculateBeholder(model);
    
    return model;
}


	/**
 * NY FUNKTION (Fase 2): Analyserer systemets topologi og tildeler kategorier.
 * - Koblingsledning: Forsyner pr√¶cis 1 tapsted.
 * - Hovedledning (Freml√∏b): Forsyner en anden streng (sektion).
 * - Fordelingsledning (Freml√∏b): Forsyner >1 tapsted i samme streng.
 * - Hovedledning (Retur): B√¶rer flow fra flere strenge.
 */
function analyzeSystemTopology(model) {
    // Helper: Find streng-ID fra node-ID (f.eks. "S1-R1" -> "S1")
    const getStringId = (nodeId) => {
        if (!nodeId || nodeId === 'Beholder') return 'Beholder';
        return nodeId.split('-')[0]; 
    };

    // Rekursiv analyse af freml√∏b
    const analyzeNode = (nodeId) => {
        const node = model.nodes.get(nodeId);
        if (!node) return { tapCount: 0, feedsOtherString: false };

        if (node.type === 'tapsted') {
            return { tapCount: 1, feedsOtherString: false };
        }

        let totalTaps = 0;
        let feedsOther = false;
        const myString = getStringId(node.id);

        node.children.forEach(child => {
            const childResult = analyzeNode(child.id);
            totalTaps += childResult.tapCount;
            
            // Tjek om barnet h√∏rer til en anden streng
            const childString = getStringId(child.id);
            if (childString !== myString && child.type !== 'tapsted' && child.id !== 'Beholder') {
                feedsOther = true;
            }
            // Hvis barnet f√∏der en anden streng, g√∏r jeg det ogs√•
            if (childResult.feedsOtherString) {
                feedsOther = true;
            }
        });

        // Tildel kategori
        if (node.type === 'ror_vv') {
            if (feedsOther) {
                node.category = 'main'; // Hovedledning (M√∏rker√∏d)
            } else if (totalTaps === 1) {
                node.category = 'connection'; // Koblingsledning (Lysr√∏d)
            } else {
                node.category = 'distribution'; // Fordelingsledning (R√∏d)
            }
        }
        
        return { tapCount: totalTaps, feedsOtherString: feedsOther };
    };

    // Start analysen fra Beholderen
    const beholder = model.nodes.get('Beholder');
    if (beholder) {
        beholder.children.forEach(child => analyzeNode(child.id));
    }

    // Analyser Retur-netv√¶rk
    // Kortl√¶g hvilke loops hvert retur-r√∏r er en del af
    const returnPipeLoops = new Map(); // Map<PipeID, Set<LoopID>>

    model.loops.forEach(loop => {
        if (!loop.path) return;
        loop.path.forEach(nodeId => {
            const node = model.nodes.get(nodeId);
            if (node && node.type === 'cirkulation_vv') {
                if (!returnPipeLoops.has(nodeId)) {
                    returnPipeLoops.set(nodeId, new Set());
                }
                returnPipeLoops.get(nodeId).add(loop.id);
            }
        });
    });

    // Tildel kategori til retur-r√∏r
    model.nodes.forEach(n => {
        if (n.type === 'cirkulation_vv') {
            const loops = returnPipeLoops.get(n.id);
            // Hvis r√∏ret indg√•r i mere end √©t unikt loop -> Hovedledning
            if (loops && loops.size > 1) {
                n.category = 'main_return'; // Hovedretur (M√∏rkebl√•)
            } else {
                n.category = 'return'; // Alm. retur (Bl√•)
            }
        }
    });
}


// =============================================================================
// == BEREGNINGSKERNE: VARMT VAND (VV)
// =============================================================================

// 1. Beregn Spidslast (VV)
function calculateQd_VV(model) {
    function traverse(node) {
        let downstream_qf_random = 0, downstream_qf_syst = 0;
        if (node.type === 'tapsted') {
            if (node.isSyst) downstream_qf_syst = node.qf; 
            else downstream_qf_random = node.qf;
        } else {
            node.children.forEach(child => {
                const flows = traverse(child);
                downstream_qf_random += flows.random; 
                downstream_qf_syst += flows.syst;
            });
        }
        if(node.type === 'ror_vv') { // Dette d√¶kker pt. kun VV r√∏r
            node.sum_qf_random = downstream_qf_random; 
            node.sum_qf_syst = downstream_qf_syst;
            const qd_random = downstream_qf_random <= 0.15 ? downstream_qf_random : 0.15 + 0.011*(downstream_qf_random-0.15) + 0.089*Math.sqrt(downstream_qf_random-0.15);
            node.qd = qd_random + downstream_qf_syst;
        }
        return { random: downstream_qf_random, syst: downstream_qf_syst };
    }
    traverse(model.tree);
    return model;
}

// 2. Dimensioner Freml√∏b (VV)
function dimensionSupply_VV(model, config) {
    model.nodes.forEach(n => {
        if (n.type !== 'ror_vv' || !n.qd) return;

        const mat = n.material;
        const sortedDims = Object.keys(ID[mat]).map(Number).sort((a, b) => a - b);
        let bestDim = sortedDims[sortedDims.length - 1]; 
        const temp = config.T_v;

        // (Samme logik som f√∏r, blot inde i denne omd√∏bte funktion)
        if (config.dimPrinciple === 'min_velocity_pressure') {
            let bestPaM = Infinity;
            let foundDim = false;
            for (const dim of sortedDims) {
                const d_i = ID[mat][dim] / 1000;
                const v = (n.qd / 1000) / (Math.PI * Math.pow(d_i / 2, 2));
                if (v >= config.min_v_f) {
                    const dp_m = getDP(n.qd, d_i, RH[mat] / 1000, 1, 0, 0, temp);
                    if (dp_m < bestPaM) { bestPaM = dp_m; bestDim = dim; foundDim = true; }
                }
            }
            if (!foundDim) bestDim = sortedDims[0];
        } else {
            for (const dim of sortedDims) {
                const d_i = ID[mat][dim] / 1000;
                const v = (n.qd / 1000) / (Math.PI * Math.pow(d_i / 2, 2));
                const dp_m = getDP(n.qd, d_i, RH[mat] / 1000, 1, 0, 0, temp);
                let criteriaMet = false;
                switch (config.dimPrinciple) {
                    case 'pressure_drop': if (dp_m < config.max_dp_m) criteriaMet = true; break;
                    case 'velocity': if (v < config.max_v_f) criteriaMet = true; break;
                    case 'combined': default: if (v < config.max_v_f && dp_m < config.max_dp_m) criteriaMet = true; break;
                }
                if (criteriaMet) { bestDim = dim; break; }
            }
        }
        n.nom_dim = bestDim;
    });
    return model;
}

// 3. Beregn Tryktab (VV)
function calculatePressureDrop_VV(startNode, dp_prop, flow_prop, config) {
    if ((startNode.type === 'ror_vv' || startNode.type === 'cirkulation_vv') && startNode.nom_dim) {
        const d_i = ID[startNode.material][startNode.nom_dim]/1000;
        const pct = config && config.fittings_pct ? config.fittings_pct : 0;
        const temp = startNode.type === 'ror_vv' ? config.T_v : (config.T_v - config.dT/2);
        
        startNode[dp_prop] = getDP(startNode[flow_prop], d_i, RH[startNode.material]/1000, startNode.L, startNode.zeta_sum, pct, temp);
    }
    startNode.children.forEach(c => calculatePressureDrop_VV(c, dp_prop, flow_prop, config));
    return startNode;
}

// 4. Find Kritisk Vej (VV)
function findMaxPathDp_VV(startNode, config) { 
    let max_dp = 0;
    let critical_path = []; 
    const rho = getWaterDensity(config.T_v); // Varmt vand

    function traverse(node, current_dp, current_path) {
        const new_dp = current_dp + (node.dp_tap || 0);
        const new_path = [...current_path, node.id];

        if (node.type === 'tapsted') {
            const forsyningsKote = config.forsyningens_kote || 0;
            const tapstedsKote = node.kote || 0;
            const h = tapstedsKote - forsyningsKote;
            const delta_p_geo = rho * G * h;
            const total_dp_for_path = new_dp + delta_p_geo;

            if (total_dp_for_path > max_dp) {
                max_dp = total_dp_for_path;
                critical_path = new_path;
            }
        } else {
            node.children.forEach(c => traverse(c, new_dp, new_path));
        }
    }
    traverse(startNode, 0, []);
    return { max_dp: max_dp, path: critical_path };
}

// 5. Beregn Varmetab (VV & VVC)
function calculateHeatLoss_VV(model, config) {
    const allowance_factor = 1 + ((config.heat_loss_pct || 0) / 100);
    model.nodes.forEach(n => {
        if ((n.type === 'ror_vv' || n.type === 'cirkulation_vv') && n.nom_dim) {
            let T_ambient = (n.location === 'outside') ? config.T_omg_ude : config.T_omg_inde;
            const u_value = (typeof n.u_value_per_meter === 'number' && isFinite(n.u_value_per_meter)) ? n.u_value_per_meter : 0;
            const base_heat_loss = u_value * n.L * (config.T_v - T_ambient);
            n.q_tab = base_heat_loss * allowance_factor;
        }
    });
    return model;
}

// 6. Dimensioner Retur (VVC)
function dimensionReturn_VV(model, config) {
    const meanTemp = config.T_v - (config.dT / 2);
    model.nodes.forEach(n => {
        if (n.type !== 'cirkulation_vv') return;
        const flow = model.circFlows.get(n.id) || 0;
        n.circ_flow = flow;
        const mat = n.material;
        const sortedDims = Object.keys(ID[mat]).map(Number).sort((a, b) => a - b);
        let bestDim = sortedDims[sortedDims.length - 1];

        for (const dim of sortedDims) {
            const d_i = ID[mat][dim] / 1000;
            const area = Math.PI * (d_i / 2) ** 2;
            const v = (flow / 1000) / area;
            const dp_m_pure = getDP(flow, d_i, RH[mat] / 1000, 1, 0, 0, meanTemp); 
            if (v <= config.max_v_c && dp_m_pure <= config.max_dp_m) {
                bestDim = dim;
                break;
            }
        }
        n.nom_dim = bestDim;
    });
    return model;
}

function getDP(flow_ls, d_inner, roughness, L, zeta, fittings_pct = 0, temp = 55) {
    if(!flow_ls || flow_ls < 0.0001) return 0;
    
    // Hent fysiske v√¶rdier for den aktuelle temperatur
    const rho = getWaterDensity(temp);
    const mu = getWaterViscosity(temp);

    // Beregn hastighed og Reynolds tal
    const v = (flow_ls/1000)/(Math.PI*Math.pow(d_inner/2, 2)); 
    const Re = (rho * v * d_inner) / mu;
    
    // Beregn lambda (friktionskoefficient)
    let lambda = 0.02;
    if (Re < 2300) { 
        lambda = 64 / Re;
    } else { 
        // Colebrook-White iteration
        for(let i=0; i<10; i++) { 
            let f = 1 / Math.sqrt(lambda); 
            f = -2 * Math.log10(roughness / (3.7 * d_inner) + 2.51 / (Re * f)); 
            lambda = 1 / (f * f); 
        } 
    }

    const dynamic_pressure = rho * Math.pow(v, 2) / 2;
    
    // Beregn friktionstab
    const pipe_friction_loss = lambda * (L / d_inner) * dynamic_pressure;
    const pipe_friction_with_allowance = pipe_friction_loss * (1 + (fittings_pct / 100));
    const fittings_loss = zeta * dynamic_pressure;

    return pipe_friction_with_allowance + fittings_loss;
}


// =============================================================================
// == CIRKULATION BEREGNING (VV)
// =============================================================================

function calculateCirculationFlows_VV(model, config) {
    if (config.dT <= 0) return model;

    // Beregn faktor dynamisk baseret p√• middeltemperatur
    const meanTemp = config.T_v - (config.dT / 2);
    const HEAT_CAPACITY_FACTOR = getHeatCapacityFactor(meanTemp) / 1000; // J/L*K

    const MIN_FLOW = 0.005; 
    const targetDrop = config.dT; 
    const maxIterations = 100; 
    
    console.group("üöÄ DEBUG: Cirkulation Konvergens (VV)");

    // TRIN 1: Initialt g√¶t
    calculateHeatLoss_VV(model, config); // KALD _VV
    model.loops.forEach(l => {
        l.path = getPath(model, l.startNodeId, l.endNodeId);
        const totalQ = l.path.reduce((sum, id) => sum + (model.nodes.get(id)?.q_tab || 0), 0);
        l.circ_flow = Math.max(MIN_FLOW, totalQ / (HEAT_CAPACITY_FACTOR * targetDrop));
    });

    // TRIN 2: KONVERGENS LOOP
    let iteration = 0;
    let converged = false;

    while (!converged && iteration < maxIterations) {
        iteration++;
        let changesMade = false;
        let maxTempDeviation = 0;
        let dimsChanged = false;

        // A. Aggregering
        calculateCirculationFlowsAggregation_VV(model); // KALD _VV

        // B. DIMENSIONERING (Hydraulisk Tjek) - Brug dimensionReturn_VV logik (inline her for optimeringens skyld)
        if (config.isAuto) {
            model.nodes.forEach(n => {
                if (n.type !== 'cirkulation_vv') return;
                
                const flow = model.circFlows.get(n.id) || 0;
                const mat = n.material;
                const currentDim = n.nom_dim;
                const sortedDims = Object.keys(ID[mat]).map(Number).sort((a, b) => a - b);
                
                let bestDim = null;
                for (const dim of sortedDims) {
                    const d_i = ID[mat][dim] / 1000;
                    const area = Math.PI * (d_i / 2) ** 2;
                    const v = (flow / 1000) / area;
                    // Tjek med middeltemperatur
                    const dp_m = getDP(flow, d_i, RH[mat] / 1000, 1, 0, config.fittings_pct, meanTemp);
                    
                    if (v <= config.max_v_c && dp_m <= config.max_dp_m) {
                        bestDim = dim;
                        break; 
                    }
                }
                if (bestDim === null) bestDim = sortedDims[sortedDims.length - 1];

                if (bestDim !== currentDim) {
                    n.nom_dim = bestDim;
                    dimsChanged = true;
                    changesMade = true;
                }
            });

            if (dimsChanged) {
                calculateInsulation(model, config);
                calculateHeatLoss_VV(model, config); // KALD _VV
            }
        }

        // C. TEMPERATUR TJEK
        model.loops.forEach(l => {
            let actualPathDrop = 0;

            l.path.forEach(nodeId => {
                const node = model.nodes.get(nodeId);
                if (node && (node.type === 'ror_vv' || node.type === 'cirkulation_vv')) {
                    const totalFlow = model.circFlows.get(nodeId);
                    if (totalFlow > 0.000001) {
                        // dT = Q / (m * c)
                        const segmentDrop = node.q_tab / (totalFlow * HEAT_CAPACITY_FACTOR);
                        actualPathDrop += segmentDrop;
                    }
                }
            });

            l._debugDrop = actualPathDrop;
            const diff = actualPathDrop - targetDrop;
            if (Math.abs(diff) > maxTempDeviation) maxTempDeviation = Math.abs(diff);

            if (Math.abs(diff) > 0.05) {
                let correction = actualPathDrop / targetDrop;
                if (correction > 1.5) correction = 1.5;
                if (correction < 0.8) correction = 0.8;

                const newFlow = l.circ_flow * correction;
                l.circ_flow = (l.circ_flow * 0.7) + (newFlow * 0.3);
                if (l.circ_flow < MIN_FLOW) l.circ_flow = MIN_FLOW;
                
                changesMade = true;
            }
        });

        if (!changesMade && maxTempDeviation < 0.05) {
            converged = true;
        }
    }

    calculateCirculationFlowsAggregation_VV(model); // KALD _VV
    
    console.log("--- Slutresultater (VV) ---");
    model.loops.forEach(l => {
        l.q_tab_tot = l.path.reduce((sum, id) => sum + (model.nodes.get(id)?.q_tab || 0), 0);
        const returTemp = config.T_v - (l._debugDrop || 0);
        console.log(`Streng ${l.id}: Flow ${(l.circ_flow*3600).toFixed(1)} l/h | Retur: ${returTemp.toFixed(2)} ¬∞C`);
    });
    console.groupEnd();
    
    return model;
}


function calculateCirculationFlowsAggregation_VV(model) {
    model.circFlows = new Map();
    model.loops.forEach(l => {
        let current = l.startNodeId;
        while (current && current !== 'Beholder') {
            model.circFlows.set(current, (model.circFlows.get(current) || 0) + l.circ_flow);
            current = model.nodes.get(current).parentId;
        }
        current = l.endNodeId;
        while (current && current !== 'Beholder') {
            model.circFlows.set(current, (model.circFlows.get(current) || 0) + l.circ_flow);
            current = model.nodes.get(current).parentId;
        }
    });
    return model;
}

function calculateCirculationDP_VV(model, config) {
    model.max_dp_circ = 0;
    const meanTemp = config.T_v - (config.dT / 2);

    model.nodes.forEach(n => { if (n.type === 'cirkulation_vv' || n.type === 'ror_vv') n.dp_circ = 0; });

    model.loops.forEach(l => {
        l.dp_circ_total = 0;
        l.selectedValve = null;

        l.path.forEach(id => {
            const n = model.nodes.get(id);
            if (!n || !n.nom_dim) return;
            const flow = model.circFlows.get(id) || 0;
            if (n.type === 'ror_vv' || n.type === 'cirkulation_vv') {
                const d_i = ID[n.material][n.nom_dim] / 1000;
                // Brug meanTemp
                const segment_dp = getDP(flow, d_i, RH[n.material] / 1000, n.L, n.zeta_sum, config.fittings_pct, meanTemp);
                n.dp_circ = (n.dp_circ || 0) + segment_dp;
                l.dp_circ_total += segment_dp;
            }
        });

        // Ventil beregning (samme logik som f√∏r, men vi sikrer at fallback bruger meanTemp)
        const valveNode = l.path.map(id => model.nodes.get(id)).find(n => n?.type === 'valve');
        let valveRequiredDp = 0; 
        
        // ... (Ventil-valg logik u√¶ndret fra sidst, men ved getDP fallback brug meanTemp) ...
        // HVIS INGEN VENTIL VALGT:
        if (!valveNode || !valveNode.valveType) {
             valveRequiredDp = getDP(l.circ_flow, 0.015, 0, 0, l.zeta, 0, meanTemp);
        } else {
            // ... (Valg logik for Static/Dynamic u√¶ndret) ...
            // Gentag logikken fra forrige svar, men jeg antager den er med i din fulde kode.
            // S√∏rg for at inkludere den her hvis du copy-paster.
            // For kortheds skyld i dette svar: (Inds√¶t ventil-logikken fra tidligere svar her)
            
             if (valveNode && valveNode.valveType && VALVE_TYPES[valveNode.valveType]) {
                const typeDef = VALVE_TYPES[valveNode.valveType];
                const flowLH = (l.circ_flow || 0) * 3600; 
                const flowLS = l.circ_flow || 0;          
                if (typeDef.type === 'dynamic') { 
                    const valveData = typeDef.data;
                    const selectedValveData = valveData.find(v => v.maxFlowLH >= flowLH);
                    if (selectedValveData) { l.selectedValve = selectedValveData; valveRequiredDp = selectedValveData.minDp || selectedValveData.deltaP_Pa; }
                } else if (typeDef.type === 'static') {
                    const valveData = typeDef.data; 
                    let bestValve = null;
                    for (const valve of valveData) {
                        const kv = valve.kv_2_5;
                        if (kv <= 0) continue;
                        const dp_kPa = Math.pow((36 * flowLS) / kv, 2);
                        const dp_Pa = dp_kPa * 1000;
                        if (dp_kPa < 25) { bestValve = { valveName: `DN ${valve.dn} (STAD)`, vvsNr: valve.vvs, kvs: valve.kvs, kv_setting: kv, minDp: dp_Pa, isStatic: true }; break; }
                    }
                    if (!bestValve && valveData.length > 0) {
                        const largest = valveData[valveData.length - 1];
                        const dp_Pa = Math.pow((36 * flowLS) / largest.kv_2_5, 2) * 1000;
                        bestValve = { valveName: `DN ${largest.dn} (STAD)`, vvsNr: largest.vvs, kvs: largest.kvs, kv_setting: largest.kv_2_5, minDp: dp_Pa, isStatic: true };
                    }
                    if (bestValve) { l.selectedValve = bestValve; valveRequiredDp = bestValve.minDp; }
                }
            }
        }

        if (valveNode) valveNode.dp_circ = valveRequiredDp;
        l.dp_circ_total += valveRequiredDp;
        if (l.dp_circ_total > model.max_dp_circ) model.max_dp_circ = l.dp_circ_total;
    });
    return model;
}

function getPath(model, startId, endId) {
    const path = new Set();
    let current = model.nodes.get(startId);
    while(current && current.id !== 'Beholder') { path.add(current.id); current = model.nodes.get(current.parentId); }
    current = model.nodes.get(endId);
    while(current && current.id !== 'Beholder') { path.add(current.id); current = model.nodes.get(current.parentId); }
    return Array.from(path);
}

function calculateBeholder(model) {
    const apartmentCount = Array.from(model.nodes.values()).filter(n => n.isApartment).length;
    model.N = apartmentCount;
    if (model.N > 0) {
        model.Pmax_veksler = 1.19 * model.N + 18.8 * Math.sqrt(model.N) + 17.6;
        model.pv_kurver = { 2: {20: 3.8, 30: 2.8, 40: 2.2, 50: 1.8}, 4: {20: 3.2, 40: 2.1, 60: 1.6}, 8: {20: 2.5, 40: 1.6, 60: 1.2, 80: 0.9}, 16: {20: 2.0, 40: 1.2, 60: 0.9, 80: 0.7}, 32: {20: 1.5, 40: 0.9, 60: 0.7, 80: 0.5}, 64: {20: 1.2, 40: 0.7, 60: 0.5, 80: 0.4}, 128: {20: 0.9, 40: 0.5, 60: 0.4, 80: 0.3} };
    }
    return model;
}

function solveBeholder(model) {
    const N = model.N;
    if (!N || N <= 0) return;
    const userEffekt = parseFloat(document.getElementById('userEffekt')?.value);
    const userVolumen = parseFloat(document.getElementById('userVolumen')?.value);
    const n_keys = Object.keys(model.pv_kurver).map(Number);
    const closest_n = n_keys.reduce((p, c) => (Math.abs(c - N) < Math.abs(p - N) ? c : p));
    const kurve = model.pv_kurver[closest_n];
    const kurveVol = Object.keys(kurve).map(Number);
    const kurveEff = Object.values(kurve);
    if (!isNaN(userEffekt) && userEffekt > 0) {
        const effektPrLejl = userEffekt / N;
        const beregnetVolumen = interpolate(effektPrLejl, [...kurveEff].reverse(), [...kurveVol].reverse());
        document.getElementById('beregnetVolumen').textContent = (beregnetVolumen * N).toFixed(0);
        document.getElementById('userVolumen').value = '';
    } else if (!isNaN(userVolumen) && userVolumen > 0) {
        const volumenPrLejl = userVolumen / N;
        const beregnetEffekt = interpolate(volumenPrLejl, kurveVol, kurveEff);
        document.getElementById('beregnetEffekt').textContent = (beregnetEffekt * N).toFixed(1);
        document.getElementById('userEffekt').value = '';
    }
}

function calculateTemperatures_VV(model, config) {
    // Brug dynamisk faktor
    const meanTemp = config.T_v - (config.dT / 2);
    const HEAT_CAPACITY_FACTOR = getHeatCapacityFactor(meanTemp) / 1000;
    
    model.nodeTemps = new Map();
    
    // Traverse Supply (VV)
    function traverseSupply(nodeId, currentTemp) {
        model.nodeTemps.set(nodeId, currentTemp);
        const node = model.nodes.get(nodeId);
        if (!node || !node.children) return;

        node.children.forEach(child => {
            if (child.type === 'ror_vv') {
                const flow = model.circFlows.get(child.id) || 0;
                let nextTemp = currentTemp;
                if (flow > 0.00001) {
                    const q_tab = child.q_tab || 0; 
                    const dt = q_tab / (flow * HEAT_CAPACITY_FACTOR);
                    nextTemp = currentTemp - dt;
                    if(nextTemp < config.T_omg_inde) nextTemp = config.T_omg_inde;
                } else {
                    nextTemp = currentTemp - 0.5;
                }
                traverseSupply(child.id, nextTemp);
            } else {
                traverseSupply(child.id, currentTemp);
            }
        });
    }
    traverseSupply('Beholder', config.T_v);

    // Retur (VV)
    model.loops.forEach(loop => {
        let t = model.nodeTemps.get(loop.startNodeId); 
        const returnNodes = loop.path.filter(id => {
            const n = model.nodes.get(id);
            return n && (n.type === 'cirkulation_vv' || n.type === 'valve');
        });
        returnNodes.forEach(nodeId => {
            const n = model.nodes.get(nodeId);
            const flow = model.circFlows.get(nodeId) || 0;
            if (!model.nodeTemps.has(nodeId) || t < model.nodeTemps.get(nodeId)) {
                model.nodeTemps.set(nodeId, t);
            }
            if (flow > 0.00001 && n.q_tab) {
                const dt = n.q_tab / (flow * HEAT_CAPACITY_FACTOR);
                t -= dt;
            }
        });
    });
}


function interpolate(x, x_pts, y_pts) {
    if (x <= x_pts[0]) return y_pts[0];
    if (x >= x_pts[x_pts.length-1]) return y_pts[y_pts.length-1];
    let i = 1;
    while (x > x_pts[i]) i++;
    return y_pts[i-1] + (y_pts[i] - y_pts[i-1]) * (x - x_pts[i-1]) / (x_pts[i] - x_pts[i-1]);
}
//... import/export funktioner (u√¶ndret) ...

function exportProject() {
    const data = {
        config: getGlobalConfig(),
        strenge_vv: [],     // NYT: VV Strenge
        cirkulation_vv: [], // NYT: VV Cirkulation
        valves: [],
        names: Array.from(state.names),
        nodePositions: state.nodes.map(n => ({ id: n.id, fx: n.fx, fy: n.fy })),
        customTapsteder: state.customTapsteder
    };

    // Gennemg√• streng-kort (Freml√∏b VV)
    document.querySelectorAll('.streng-card').forEach(card => {
        const strengData = {
            id: card.dataset.id,
            ror: [],
            tapsted: [],
            circ_start: card.querySelector('.circ-start').value,
            circ_end: card.querySelector('.circ-end').value,
            circ_zeta: parseFloat(card.querySelector('.circ-zeta').value) || 0
        };

        // S√∏g efter ror_vv
        card.querySelectorAll('.ror-container > tr[data-type="ror_vv"]').forEach(el => {
            strengData.ror.push({
                id: el.dataset.id,
                parent: el.querySelector('.parent').value,
                material: el.querySelector('.material').value,
                location: el.querySelector('.location').value,
                insulationClassSelection: el.querySelector('.insulation-class')?.value || 'Auto',
                dim: el.querySelector('.dim').value, 
                len: parseFloat(el.querySelector('.len').value),
                fittings: parseFloat(el.querySelector('.fittings').value)
            });
        });

        // Tapsteder (u√¶ndret)
        card.querySelectorAll('.tapsted-container > tr[data-type="tapsted"]').forEach(el => {
            strengData.tapsted.push({
                id: el.dataset.id,
                parent: el.querySelector('.parent').value,
                tapType: el.querySelector('.tapType').options[el.querySelector('.tapType').selectedIndex].text,
                qf: parseFloat(el.querySelector('.qf').value),
                kote: parseFloat(el.querySelector('.kote').value) || 0,
                syst: el.querySelector('.syst').checked,
                isApartment: el.dataset.isApartment === 'true'
            });
        });
        
        data.strenge_vv.push(strengData);
    });

    // Indsaml Cirkulation VV (tidl. Retur)
    document.querySelectorAll('#returContainerBody > tr[data-type="cirkulation_vv"]').forEach(el => {
        data.cirkulation_vv.push({
            id: el.dataset.id,
            parent: el.querySelector('.parent').value,
            material: el.querySelector('.material').value,
            location: el.querySelector('.location').value,
            insulationClassSelection: el.querySelector('.insulation-class')?.value || 'Auto',
            dim: el.querySelector('.dim').value, 
            len: parseFloat(el.querySelector('.len').value),
            fittings: parseFloat(el.querySelector('.fittings').value)
        });
    });

    // Indsaml Ventiler
    document.querySelectorAll('#returContainerBody > tr[data-type="valve"]').forEach(el => {
        data.valves.push({
            id: el.dataset.id,
            parent: el.querySelector('.parent').value,
            valveType: el.querySelector('.valve-type-select')?.value || el.dataset.valveType
        });
    });

    // Filnavn og download
    const projName = data.config.projectName ? data.config.projectName.replace(/[^a-z0-9√¶√∏√•]/gi, '_') : 'Brugsvand_VV_Projekt';
    const now = new Date();
    const dateStr = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
    const filename = `${projName}_${dateStr}.json`;

    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * NY FUNKTION (Fase 4): Omd√∏ber alle komponenter logisk og sorterer tabellerne.
 * 1. Gemmer nuv√¶rende tilstand.
 * 2. Analyserer flow-strukturen.
 * 3. Tildeler nye ID'er (S1-R1, S1-R2...) i flow-r√¶kkef√∏lge.
 * 4. Genindl√¶ser projektet.
 */
function renumberAndSortProject() {
    if (!confirm("Vil du omd√∏be og sortere hele projektet?\n\nDette vil:\n1. Give alle komponenter nye, logiske numre (f.eks. S1-R1).\n2. Konvertere data til nyeste format (VV).\n3. Sortere tabellerne efter flow-retning.")) {
        return;
    }

    // 1. Gem nuv√¶rende tilstand for at f√• fat i data-objektet
    autoSaveProject(); 
    const rawData = localStorage.getItem('varmtBrugsvandAutoSave');
    if (!rawData) return;
    
    const data = JSON.parse(rawData);
    const idMap = new Map(); 
    idMap.set('Beholder', 'Beholder');

    // H√•ndter b√•de nye og gamle feltnavne
    const strengeData = data.strenge_vv || data.strenge;
    const cirkulationData = data.cirkulation_vv || data.retur;

    // --- A. OMD√òB STRENGE & FREML√òB (VV) ---
    if (strengeData) {
        strengeData.sort((a, b) => {
            const numA = parseInt(a.id.replace('S', '')) || 0;
            const numB = parseInt(b.id.replace('S', '')) || 0;
            return numA - numB;
        });

        strengeData.forEach((streng, index) => {
            const newStringId = `S${index + 1}`;
            idMap.set(streng.id, newStringId);
            streng.id = newStringId;

            const components = [...(streng.ror || []), ...(streng.tapsted || [])];
            
            // Simpel sortering: Sorter efter om de har en for√¶lder i samme streng (Graf-sortering er bedre, men dette virker til husbehov)
            // En bedre l√∏sning er at bruge den eksisterende graf-traversering hvis muligt, men her laver vi en simpel ID-baseret rensning
            
            // Tildel nye ID'er
            let rCount = 0, tCount = 0;
            
            // Vi pr√∏ver at bevare den relative r√¶kkef√∏lge fra arrayet, da brugeren ofte har oprettet dem i r√¶kkef√∏lge
            components.forEach(c => {
                const oldId = c.id;
                let newId;
                
                // Tjek type
                if (c.hasOwnProperty('material')) { // R√∏r
                    rCount++;
                    newId = `${newStringId}-R${rCount}`;
                } else { // Tapsted
                    tCount++;
                    newId = `${newStringId}-T${tCount}`;
                }
                
                idMap.set(oldId, newId);
                c.id = newId;
            });
        });
        
        // GEM I NY STRUKTUR OG SLET GAMMEL
        data.strenge_vv = strengeData;
        delete data.strenge;
    }

    // --- B. OMD√òB CIRKULATION (VV) & VENTILER ---
    if (cirkulationData || data.valves) {
        const returComps = [...(cirkulationData || []), ...(data.valves || [])];
        
        // Sorter efter eksisterende ID nummer for at bevare en vis orden
        returComps.sort((a,b) => {
             const nA = parseInt(a.id.replace(/\D/g, '')) || 0;
             const nB = parseInt(b.id.replace(/\D/g, '')) || 0;
             return nA - nB;
        });

        let returCount = 0, valveCount = 0;
        
        returComps.forEach(c => {
            const oldId = c.id;
            let newId;
            
            if (c.hasOwnProperty('valveType')) { // Ventil
                valveCount++;
                newId = `V${valveCount}`;
            } else { // Cirkulationsr√∏r
                returCount++;
                newId = `Retur${returCount}`; // Vi beholder "Retur" navnet i ID'et, selvom typen er cirkulation_vv
            }
            idMap.set(oldId, newId);
            c.id = newId;
        });

        // Split data igen og gem i nye felter
        data.cirkulation_vv = returComps.filter(c => !c.hasOwnProperty('valveType'));
        delete data.retur;
        
        data.valves = returComps.filter(c => c.hasOwnProperty('valveType'));
    }

    // --- C. OPDATER REFERENCER ---
    const updateId = (id) => idMap.has(id) ? idMap.get(id) : id;
    const updateParents = (list) => { if (list) list.forEach(i => i.parent = updateId(i.parent)); };
    
    if (data.strenge_vv) {
        data.strenge_vv.forEach(s => {
            updateParents(s.ror);
            updateParents(s.tapsted);
            s.circ_start = updateId(s.circ_start);
            s.circ_end = updateId(s.circ_end);
        });
    }
    updateParents(data.cirkulation_vv);
    updateParents(data.valves);

    // Opdater navne
    const newNames = [];
    if (data.names) {
        data.names.forEach(([oldId, name]) => {
            if (idMap.has(oldId)) newNames.push([idMap.get(oldId), name]);
        });
    }
    data.names = newNames;
    
    // Opdater positioner
    if (data.nodePositions) {
        data.nodePositions.forEach(pos => {
            if (idMap.has(pos.id)) pos.id = idMap.get(pos.id);
        });
    }

    // --- D. GENINDL√ÜS ---
    console.log("Refactoring f√¶rdig. Migreret til VV-format.", idMap);
    loadProjectData(data);
    autoSaveProject(); // Gem det nye rene format
}

/**
 * OPDATERET FUNKTION: Gemmer den nuv√¶rende projekt-tilstand til localStorage.
 * Denne version matcher nu 100% logikken i exportProject.
 */
function autoSaveProject() {
    // Konstruer data-objektet pr√¶cis som i exportProject
    const data = {
        config: getGlobalConfig(),
        strenge_vv: [], 
        cirkulation_vv: [], 
        valves: [],
        names: Array.from(state.names),
        nodePositions: state.nodes.map(n => ({ id: n.id, fx: n.fx, fy: n.fy })),
        customTapsteder: state.customTapsteder
    };

    // Gennemg√• streng-kort (Freml√∏b VV)
    document.querySelectorAll('.streng-card').forEach(card => {
        const strengData = {
            id: card.dataset.id,
            ror: [],
            tapsted: [],
            circ_start: card.querySelector('.circ-start').value,
            circ_end: card.querySelector('.circ-end').value,
            circ_zeta: parseFloat(card.querySelector('.circ-zeta').value) || 0
        };

        // S√∏g efter ror_vv
        card.querySelectorAll('.ror-container > tr[data-type="ror_vv"]').forEach(el => {
            strengData.ror.push({
                id: el.dataset.id,
                parent: el.querySelector('.parent').value,
                material: el.querySelector('.material').value,
                location: el.querySelector('.location').value,
                insulationClassSelection: el.querySelector('.insulation-class')?.value || 'Auto',
                dim: el.querySelector('.dim').value, 
                len: parseFloat(el.querySelector('.len').value),
                fittings: parseFloat(el.querySelector('.fittings').value)
            });
        });

        // Tapsteder (u√¶ndret)
        card.querySelectorAll('.tapsted-container > tr[data-type="tapsted"]').forEach(el => {
            strengData.tapsted.push({
                id: el.dataset.id,
                parent: el.querySelector('.parent').value,
                tapType: el.querySelector('.tapType').options[el.querySelector('.tapType').selectedIndex].text,
                qf: parseFloat(el.querySelector('.qf').value),
                kote: parseFloat(el.querySelector('.kote').value) || 0,
                syst: el.querySelector('.syst').checked,
                isApartment: el.dataset.isApartment === 'true'
            });
        });
        
        data.strenge_vv.push(strengData);
    });

    // Indsaml Cirkulation VV (tidl. Retur)
    document.querySelectorAll('#returContainerBody > tr[data-type="cirkulation_vv"]').forEach(el => {
        data.cirkulation_vv.push({
            id: el.dataset.id,
            parent: el.querySelector('.parent').value,
            material: el.querySelector('.material').value,
            location: el.querySelector('.location').value,
            insulationClassSelection: el.querySelector('.insulation-class')?.value || 'Auto',
            dim: el.querySelector('.dim').value, 
            len: parseFloat(el.querySelector('.len').value),
            fittings: parseFloat(el.querySelector('.fittings').value)
        });
    });

    // Indsaml Ventiler
    document.querySelectorAll('#returContainerBody > tr[data-type="valve"]').forEach(el => {
        data.valves.push({
            id: el.dataset.id,
            parent: el.querySelector('.parent').value,
            valveType: el.querySelector('.valve-type-select')?.value || el.dataset.valveType
        });
    });

    // Gem til localStorage
    try {
        localStorage.setItem('varmtBrugsvandAutoSave', JSON.stringify(data));
        projektEr√Ündret = false; 
        console.log("Projekt auto-gemt (VV format)."); 
    } catch (err) {
        console.error("Fejl ved auto-gem:", err);
    }
}


/**
 * NY FUNKTION (TRIN 3): S√¶tter "dirty flag" for at indikere, at der er √¶ndringer.
 */
function setProjektEr√Ündret() {
    // console.log("Projekt er √¶ndret, s√¶tter flag."); // Til debugging
    projektEr√Ündret = true;
}

/**
 * NY FUNKTION (TRIN 3): K√∏rer periodisk og gemmer, HVIS der er √¶ndringer.
 */
function checkAndAutoSave() {
    if (projektEr√Ündret) {
        console.log("5-minutters interval: Gemmer √¶ndringer...");
        autoSaveProject(); // autoSaveProject nulstiller selv flaget
    } else {
        // console.log("5-minutters interval: Ingen √¶ndringer at gemme."); // Til debugging
    }
}

/**
 * NY FUNKTION (TRIN 4): Nulstiller projektet ved at rydde localStorage.
 */
function resetProject() {
    if (confirm("Er du sikker p√•, du vil starte et nyt projekt?\n\nDette vil slette dit nuv√¶rende arbejde og eventuelle auto-gemte data.")) {
        try {
            localStorage.removeItem('varmtBrugsvandAutoSave');
            console.log("Auto-gem er ryddet. Siden genindl√¶ses.");
        } catch (err) {
            console.error("Kunne ikke rydde localStorage:", err);
        }
        location.reload();
    }
}

	
/**
 * OPDATERET FUNKTION: H√•ndterer kun fil-import og kalder loadProjectData.
 */
function importProject(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            loadProjectData(data);
        } catch (err) {
            alert("Fejl: Kunne ikke indl√¶se projektfilen. Er filen korrupt?\n\n" + err.message);
        }
    };
    reader.onerror = () => {
        alert("Fejl: Kunne ikke l√¶se filen.");
    };
    reader.readAsText(file);
}

function loadProjectData(data) {
    if (!data) return;
    console.log("Starter indl√¶sning...", data);
    
    // Nulstil UI
    document.getElementById('strengeContainer').innerHTML = '';
    document.getElementById('returContainerBody').innerHTML = ''; 
    document.getElementById('customTapsteder').innerHTML = '';
    
    state.sC = 0; state.rC = 0; state.tC = 0; valveCounter = 0;
    let maxS = 0, maxR = 0, maxT = 0, maxV = 0;

    // --- TRIN 0: DATA NORMALISERING (Bagudkompatibilitet) ---
    // Vi samler data fra b√•de nye (_vv) og gamle felter
    const strengeData = data.strenge_vv || data.strenge || [];
    const cirkulationData = data.cirkulation_vv || data.retur || [];
    const valvesData = data.valves || [];

    try {
        // Find max ID-numre for at forts√¶tte t√¶lling korrekt
        if (strengeData) {
            strengeData.forEach(streng => {
                const sNum = parseInt(streng.id.replace('S', ''), 10);
                if (!isNaN(sNum) && sNum > maxS) maxS = sNum;
                const components = [...(streng.ror || []), ...(streng.tapsted || [])];
                components.forEach(comp => {
                    // H√•ndter b√•de gamle S1-R1 og nye S1-R1
                    const idParts = comp.id.split(/[RT-]/);
                    const tNum = parseInt(idParts[idParts.length - 1], 10);
                    if (!isNaN(tNum) && tNum > maxT) maxT = tNum;
                });
            });
        }
        if (cirkulationData) {
            cirkulationData.forEach(r => {
                const rNum = parseInt(r.id.replace('Retur', ''), 10);
                if (!isNaN(rNum) && rNum > maxR) maxR = rNum;
            });
        }
        if (valvesData) { 
            valvesData.forEach(v => {
                const vNum = parseInt(v.id.replace('V', ''), 10);
                if (!isNaN(vNum) && vNum > maxV) maxV = vNum;
            });
        }
        
        state.sC = maxS; state.rC = maxR; state.tC = maxT; valveCounter = maxV;

        state.names = new Map(data.names);
        if (data.nodePositions) state.nodes = data.nodePositions;
        state.customTapsteder = data.customTapsteder || {}; 
        
        // Indl√¶s tapsteder (H√•ndterer ny struktur med qf_hot)
        Object.assign(ST, data.customTapsteder ? Object.fromEntries(Object.entries(data.customTapsteder).map(([k, v]) => [k, v.qf_hot || v.qf])) : {});
        
        if (data.config) {
            Object.entries(data.config).forEach(([k, v]) => {
                const el = document.getElementById(k);
                if (el) el.value = v;
                if (k === 'isAuto') document.getElementById('autoDimToggle').checked = v;
            });
            toggleAutoDim(data.config.isAuto);
        }

        // Genskab custom tapsteder i UI
        Object.keys(state.customTapsteder).forEach(k => {
            const clone = document.getElementById('customTapstedTemplate').content.cloneNode(true);
            clone.querySelector('.input-group-text').dataset.key = k;
            clone.querySelector('.input-group-text').textContent = k;
            // Underst√∏t b√•de ny og gammel data-struktur
            const val = state.customTapsteder[k];
            clone.querySelector('.qf').value = val.qf_hot !== undefined ? val.qf_hot : val.qf;
            clone.querySelector('.is-apartment').checked = val.isApartment;
            document.getElementById('customTapsteder').appendChild(clone);
        });
    } catch (e) {
        console.error("Fejl i Trin 0 (Forberedelse):", e);
    }

    // --- TRIN 1: OPRET ELEMENTER I DOM ---
    const setCommonFields = (tr, item) => {
        if (tr.dataset.tempParent) tr.dataset.tempParent = item.parent || "Beholder";
        
        const matSelect = tr.querySelector('.material');
        if (matSelect && item.material) {
            matSelect.value = item.material;
            matSelect.onchange = handleMaterialChange; 
        }
        
        const locSelect = tr.querySelector('.location');
        if (locSelect && item.location) locSelect.value = item.location;
        
        const isoInput = tr.querySelector('.insulation-class');
        if (isoInput) isoInput.value = item.insulationClassSelection || 'Auto';
        
        const lenInput = tr.querySelector('.len');
        if (lenInput) lenInput.value = item.len || 10;
        
        const fitInput = tr.querySelector('.fittings');
        if (fitInput) fitInput.value = item.fittings || 0;
        
        const nameInput = tr.querySelector('.name-text');
        if (nameInput) nameInput.onchange = (e) => state.names.set(item.id, e.target.value);
    };

    // A. INDL√ÜS STRENGE (Freml√∏b VV)
    if (strengeData) {
        strengeData.forEach(streng => {
            const clone = document.getElementById('strengTemplate').content.cloneNode(true);
            const card = clone.querySelector('.card');
            card.dataset.id = streng.id;
            card.querySelector('.id-text').textContent = `VV-Streng ${streng.id}`; // Opdateret label
            
            card.dataset.tempCircStart = streng.circ_start;
            card.dataset.tempCircEnd = streng.circ_end;
            card.querySelector('.circ-zeta').value = streng.circ_zeta || 0;

            document.getElementById('strengeContainer').appendChild(clone);
            const rorContainer = card.querySelector('.ror-container');
            const tapstedContainer = card.querySelector('.tapsted-container');
            
            // R√∏r i strengen (Konverteres til ror_vv)
            (streng.ror || []).forEach(r => {
                const id = r.id;
                const tr = document.createElement('tr');
                tr.dataset.id = id;
                tr.dataset.type = 'ror_vv'; // TVING NY TYPE
                tr.dataset.tempParent = r.parent; 
                const datalistId = `list-${id}`;
                
                tr.innerHTML = `
                    <td><span class="input-group input-group-sm"><span class="input-group-text id-text">${id}</span><input type="text" class="form-control name-input d-none name-text" placeholder="Navn"></span></td>
                    <td><select class="form-select form-select-sm parent" title="For√¶lder"></select></td>
                    <td><select class="form-select form-select-sm material" title="Materiale">
                        <option value="Kobber">Kobber</option><option value="Rustfri Press 316L">Rustfri Press 316L</option><option value="Rustfri Svejse 316L">Rustfri Svejse 316L</option>
                        <option value="Pex">Pex</option><option value="Alupex">Alupex</option><option value="PE100">PE100</option><option value="Geberit Mepla">Geberit Mepla</option>
                    </select></td>
                    <td><select class="form-select form-select-sm location" title="Placering"><option value="heated">Opvarmet rum</option><option value="unheated">Uopvarmet rum</option><option value="outside">Udend√∏rs</option></select></td>
                    <td><input type="text" class="form-control form-control-sm insulation-class" list="insulationClassOptions" title="Isol."></td>
                    <td><input type="text" class="form-control form-control-sm dim-input dim" value="${r.dim}" title="Dim" list="${datalistId}"><datalist id="${datalistId}"></datalist></td>
                    <td><input type="number" min="0" class="form-control form-control-sm len" title="L√¶ngde"></td>
                    <td><input type="number" min="0" class="form-control form-control-sm fittings" title="Zeta"></td>
                    <td><button class="btn btn-sm btn-outline-danger" onclick="removeElement(this)" title="Fjern">&times;</button></td>
                `;
                
                setCommonFields(tr, r);
                rorContainer.appendChild(tr);
                
                const matSelect = tr.querySelector('.material');
                if (matSelect) updateDimOptions(matSelect); 
            });
            
            // Tapsteder
            (streng.tapsted || []).forEach(t => {
                const id = t.id;
                const tr = document.createElement('tr');
                tr.dataset.id = id;
                tr.dataset.type = 'tapsted';
                tr.dataset.tempParent = t.parent; 

                let opts = '';
                // Brug qf_hot til value
                const allTap = {...ST, ...Object.fromEntries(Object.entries(state.customTapsteder).map(([k, v]) => [k, v.qf_hot !== undefined ? v : {qf_hot: v.qf, isApartment: v.isApartment}]))};
                
                Object.keys(allTap).forEach(k => {
                    const data = allTap[k];
                    const val = data.qf_hot !== undefined ? data.qf_hot : data; // H√•ndter gammel/ny
                    const isApt = data.isApartment !== undefined ? data.isApartment : k.includes('Lejlighed');
                    opts += `<option value="${val}" data-is-apartment="${isApt}">${k}</option>`;
                });
                
                tr.innerHTML = `
                    <td><span class="input-group input-group-sm"><span class="input-group-text id-text">${id}</span><input type="text" class="form-control name-input d-none name-text" placeholder="Navn"></span></td>
                    <td><select class="form-select form-select-sm parent" title="For√¶lder"></select></td>
                    <td><select class="form-select form-select-sm tapType" onchange="handleInputChange(event)" title="Type">${opts}</select></td>
                    <td><input type="number" class="form-control form-control-sm qf" min="0" value="${t.qf}" step="0.01" title="qf"></td>
                    <td><input type="number" class="form-control form-control-sm kote allow-negative" value="${t.kote || 0}" title="Kote"></td>
                    <td class="text-center"><input type="checkbox" class="form-check-input syst" title="Syst." ${t.syst ? 'checked' : ''}></td>
                    <td><button class="btn btn-sm btn-outline-danger" onclick="removeElement(this)" title="Fjern">&times;</button></td>
                `;
                
                const tapSelect = tr.querySelector('.tapType');
                let foundIdx = Array.from(tapSelect.options).findIndex(opt => opt.text === t.tapType);
                if (foundIdx === -1 && t.qf) { 
                     foundIdx = Array.from(tapSelect.options).findIndex(opt => parseFloat(opt.value) === parseFloat(t.qf));
                }
                if (foundIdx !== -1) tapSelect.selectedIndex = foundIdx;

                tr.dataset.isApartment = t.isApartment ? 'true' : 'false';
                tr.querySelector('.name-text').onchange = (e) => state.names.set(id, e.target.value);
                
                tapstedContainer.appendChild(tr);
            });
        });
    }

    // B. INDL√ÜS CIRKULATION (Retur VV)
    // Vi bruger data fra 'cirkulation_vv' (eller 'retur' for gamle filer)
    if (cirkulationData) {
        cirkulationData.forEach(r => {
            const id = r.id;
            const clone = document.getElementById('returRorTRTemplate').content.cloneNode(true);
            const tr = clone.querySelector('tr');
            
            tr.dataset.id = id;
            tr.dataset.type = 'cirkulation_vv'; // TVING NY TYPE
            tr.dataset.tempParent = r.parent; 
            
            const datalistId = `list-${id}`;
            const dimInput = tr.querySelector('.dim-input');
            const datalist = tr.querySelector('datalist');
            dimInput.setAttribute('list', datalistId);
            datalist.id = datalistId;
            dimInput.value = r.dim; 

            tr.querySelector('.id-text').textContent = id;
            
            setCommonFields(tr, r); 
            
            document.getElementById('returContainerBody').appendChild(clone);
            
            const matSelect = tr.querySelector('.material');
            if (matSelect) updateDimOptions(matSelect); 
        });
    }
    
    // C. INDL√ÜS VENTILER
    if (valvesData) {
        valvesData.forEach(v => {
            const id = v.id;
            const clone = document.getElementById('valveTRTemplate').content.cloneNode(true);
            const tr = clone.querySelector('tr');
            tr.dataset.id = id;
            tr.dataset.valveType = v.valveType;
            tr.dataset.tempParent = v.parent; 
            
            const valveSelect = tr.querySelector('.valve-type-select');
            let opts = '<option value="" disabled>V√¶lg type...</option>';
            for (const typeName in VALVE_TYPES) {
                opts += `<option value="${typeName}">${typeName}</option>`;
            }
            valveSelect.innerHTML = opts;
            valveSelect.value = v.valveType || ""; 

            const idText = tr.querySelector('.id-text');
            idText.textContent = `${id} (${(v.valveType || 'V√¶lg').substring(0, 10)}...)`;

            valveSelect.onchange = (e) => {
                const newType = e.target.value;
                tr.dataset.valveType = newType;
                idText.textContent = `${id} (${newType.substring(0, 10)}...)`;
            };

            tr.querySelector('.name-input').onchange = (ev) => state.names.set(id, ev.target.value);
            document.getElementById('returContainerBody').appendChild(clone);
        });
    }

    // --- TRIN 2-4: FORBINDELSER OG AFSLUTNING (U√¶ndret logik) ---
    try {
        updateAllSelects();
    } catch (e) { console.error("Fejl i updateAllSelects:", e); }

    document.querySelectorAll('tr[data-temp-parent]').forEach(tr => {
        const parentSelect = tr.querySelector('.parent');
        const savedParent = tr.dataset.tempParent;
        if (parentSelect && savedParent) {
            parentSelect.value = savedParent;
            if (parentSelect.value !== savedParent) parentSelect.value = "Beholder";
        }
        delete tr.dataset.tempParent;
    });

    document.querySelectorAll('.streng-card').forEach(card => {
        const startSelect = card.querySelector('.circ-start');
        const endSelect = card.querySelector('.circ-end');
        if (card.dataset.tempCircStart) startSelect.value = card.dataset.tempCircStart;
        if (card.dataset.tempCircEnd) endSelect.value = card.dataset.tempCircEnd;
        delete card.dataset.tempCircStart;
        delete card.dataset.tempCircEnd;
    });

    try {
        updateAllSelects();
        toggleDisplayNames(state.useNames);
        setTimeout(() => { if (typeof zoomToFit === 'function') zoomToFit(); }, 100);
    } catch (e) { console.error("Fejl i Afslutning:", e); }
    
    console.log("Projekt indl√¶st f√¶rdigt (VV Refactored).");
}

/**
 * FUNKTION: Udl√∏ses af knappen "Eksport Detaljer (JSON)".
 * Starter genereringen og downloader filen.
 */
function exportDetailedResults() {
    if (!state.lastModel || !state.lastConfig) {
        alert('Du skal f√∏rst k√∏re en beregning for at kunne eksportere resultater.');
        return;
    }
    
    // Kald generator-funktionen (som vi lavede i forrige trin)
    const data = generateDetailedResults(state.lastModel, state.lastConfig);
    
    const projName = state.lastConfig.projectName ? state.lastConfig.projectName.replace(/[^a-z0-9√¶√∏√•]/gi, '_') : 'Brugsvand';
    
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hour = String(now.getHours()).padStart(2, '0');
    const minute = String(now.getMinutes()).padStart(2, '0');
    const dateStr = `${year}-${month}-${day}_${hour}-${minute}`;

    const filename = `${projName}_Detaljer_${dateStr}.json`;

    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * (HVIS DU MANGLER DENNE): Genererer datastrukturen.
 * (Inds√¶t kun hvis du ikke allerede har den fra forrige trin)
 */
function generateDetailedResults(model, config) {
    // Hj√¶lper til at overs√¶tte kategorier
    const translateCategory = (cat) => {
        const map = {
            'main': 'Hovedledning (Freml√∏b)',
            'distribution': 'Fordelingsledning (Freml√∏b)',
            'connection': 'Koblingsledning (Freml√∏b)',
            'main_return': 'Hovedledning (Retur)',
            'return': 'Returledning'
        };
        return map[cat] || 'Ukendt';
    };

    // 1. Konverter Nodes til Array
    const nodesExport = Array.from(model.nodes.values()).map(n => {
        const nodeData = {
            ID: n.id,
            Navn: n.name || '',
            Type: n.type,
            For√¶lder: n.parentId || 'Ingen'
        };

        if (n.type === 'ror_vv' || n.type === 'cirkulation_vv') {
            Object.assign(nodeData, {
                Materiale: n.material,
                Dimension: n.nom_dim + ' mm',
                L√¶ngde: n.L + ' m',
                Placering: n.location === 'outside' ? 'Udend√∏rs' : (n.location === 'unheated' ? 'Uopvarmet' : 'Opvarmet'),
                Kategori: translateCategory(n.category),
                Flow_ls: n.type === 'ror_vv' ? (n.qd || 0).toFixed(4) : (n.circ_flow || 0).toFixed(4),
                Hastighed_ms: calcVelocity(n, model).toFixed(2),
                Zeta_sum: n.zeta_sum,
                Tryktab_Total_Pa: (n.type === 'ror_vv' ? n.dp_tap : n.dp_circ || 0).toFixed(0),
                Tryktab_pr_m_Pa: ((n.type === 'ror_vv' ? n.dp_tap : n.dp_circ || 0) / (n.L || 1)).toFixed(1),
                Isolering_Klasse: n.insulationClass ? `Kl. ${n.insulationClass}` : 'Auto',
                Isolering_Tykkelse: (n.insulationThickness || 0) + ' mm',
                U_v√¶rdi_W_mK: (n.u_value_per_meter || 0).toFixed(3),
                Varmetab_W: (n.q_tab || 0).toFixed(1)
            });
        }

        if (n.type === 'tapsted') {
            Object.assign(nodeData, {
                Normflow_qf: n.qf,
                Systematisk: n.isSyst ? 'Ja' : 'Nej',
                Lejlighed: n.isApartment ? 'Ja' : 'Nej',
                Kote: n.kote
            });
        }
        
        if (n.type === 'valve') {
            Object.assign(nodeData, {
                Ventil_Type: n.valveType || 'Ukendt'
            });
        }

        return nodeData;
    });

    // 2. Cirkulations-loops
    const loopsExport = model.loops.map(l => ({
        Streng_ID: l.id,
        Start_Node: l.startNodeId,
        Slut_Node: l.endNodeId,
        Ventil_Type: l.selectedValve ? (l.selectedValve.valveName || l.selectedValve.freseNr) : 'Ingen/Manuel',
        Total_Varmetab_W: (l.q_tab_tot || 0).toFixed(1),
        Cirkulationsflow_lh: ((l.circ_flow || 0) * 3600).toFixed(1),
        Tryktab_Streng_Total_Pa: (l.dp_circ_total || 0).toFixed(0),
        // For dynamisk er minDp vigtigst, for statisk er det resttrykket
        Ventil_Data: l.selectedValve ? {
            Type: l.selectedValve.isStatic ? 'Statisk' : 'Dynamisk',
            Min_DP_Pa: l.selectedValve.minDp || 0,
            VVS_Nr: l.selectedValve.vvsNr
        } : null
    }));

    return {
        Projekt_Info: {
            Dato: new Date().toLocaleString(),
            Konfiguration: config
        },
        Resultat_Sammendrag: {
            Max_Tryktab_Tapning_Pa: model.max_dp_tapning,
            Max_Tryktab_Cirkulation_Pa: model.max_dp_circ,
            Resttryk_Kritisk_Tapsted_Pa: config.pln - model.max_dp_tapning
        },
        Komponent_Liste: nodesExport,
        Cirkulations_Strenge: loopsExport
    };
}

// Lille hj√¶lper til hastighedsberegning
function calcVelocity(n, model) {
    if (!n.nom_dim) return 0;
    const flow_ls = n.type === 'ror_vv' ? (n.qd || 0) : (model.circFlows.get(n.id) || 0);
    const d_i = ID[n.material][n.nom_dim] / 1000;
    const area = Math.PI * (d_i / 2) ** 2;
    return n.L > 0 && area > 0 ? (flow_ls / 1000) / area : 0;
}


// =============================================================================
// == VISNING AF RESULTATER (Med Temperaturafh√¶ngig Fysik)
// =============================================================================
function displayResults(model, config) {
    const advarslerDiv = document.getElementById('advarsler');
    advarslerDiv.innerHTML = '';
    
    // 1. TJEK FORSYNINGSTRYK
    const resttryk = config.pln - model.max_dp_tapning;
    if (resttryk < config.min_tap_tryk) {
        advarslerDiv.innerHTML += `<p class="alert alert-danger">ADVARSEL: Tryk ved fjerneste tapsted (${(resttryk / 1000).toFixed(0)} kPa) er for lavt (Krav: ${(config.min_tap_tryk/1000).toFixed(0)} kPa).</p>`;
    } else {
        advarslerDiv.innerHTML += `<p class="alert alert-success">OK: Tryk ved fjerneste tapsted er tilstr√¶kkeligt (${(resttryk / 1000).toFixed(0)} kPa).</p>`;
    }

    // 2. OPDATER INPUT-FELTER (HVIS AUTO-DIM)
    if (config.isAuto) {
        model.nodes.forEach(n => {
            if ((n.type === 'ror_vv' || n.type === 'cirkulation_vv') && n.nom_dim) {
                const el = document.querySelector(`[data-id="${n.id}"]`);
                if (el) {
                    const dimInput = el.querySelector('.dim');
                    if (dimInput) dimInput.value = n.nom_dim;
                }
            }
        });
    }

    // 3. BEREGN OPSUMMERINGSTAL
    let dp_friction = model.max_dp_tapning;
    let dp_geo = 0;

    // Hent densitet for varmt vand (Freml√∏b) til geod√¶tisk beregning
    // getWaterDensity(t) skal v√¶re defineret i din hj√¶lpe-sektion
    const rho_supply = getWaterDensity(config.T_v);
    
    if (model.criticalPath && model.criticalPath.size > 0) {
        const criticalPathArray = Array.from(model.criticalPath);
        const endTapstedId = criticalPathArray[criticalPathArray.length - 1];
        const endTapstedNode = model.nodes.get(endTapstedId);

        if (endTapstedNode && endTapstedNode.type === 'tapsted') {
            const h = (endTapstedNode.kote || 0) - (config.forsyningens_kote || 0);
            // Beregn l√∏fteh√∏jde-tryk med den korrekte temperatur-afh√¶ngige densitet
            dp_geo = rho_supply * G * h;
            dp_friction = model.max_dp_tapning - dp_geo;
        }
    }
    
    const total_circ_flow_lh = model.loops.reduce((s, l) => s + (l.circ_flow || 0), 0) * 3600;

    // Beregn pumpe mVs med gennemsnitlig densitet for cirkulationsvandet
    // Da returvandet er koldere, er densiteten lidt h√∏jere
    const meanTemp = config.T_v - (config.dT / 2);
    const rho_circ = getWaterDensity(meanTemp);

    // 4. OPSUMMERINGSTABEL
    document.getElementById('summaryTableBody').innerHTML = `
        <tr><td>Tryktab (Friktion)</td><td>${dp_friction.toFixed(0)} Pa</td></tr>
        <tr><td>Tryktab (L√∏fteh√∏jde)</td><td>${dp_geo.toFixed(0)} Pa</td></tr>
        <tr><td><b>Samlet tryktab (kritisk streng)</b></td><td><b>${model.max_dp_tapning.toFixed(0)} Pa</b></td></tr>
        <tr class="table-group-divider"><td colspan="2" class="bg-light"><b>Pumpe Dimensionering</b></td></tr>
        <tr><td>Pumpeflow (total)</td><td><b>${total_circ_flow_lh.toFixed(1)} l/h</b></td></tr>
        <tr><td>Pumpetryk (l√∏fteh√∏jde)</td><td><b>${model.max_dp_circ.toFixed(0)} Pa</b> (${(model.max_dp_circ / (rho_circ * G)).toFixed(2)} mVs)</td></tr>`;

    // 5. BEHOLDER INFO (METODE A)
    const metodeA_div = document.getElementById('metodeA_content');
    if (model.N > 0) {
        metodeA_div.innerHTML = `
            <p>Systemet indeholder <b>${model.N}</b> lejligheder. For et system uden beholder er det beregnede spidslastbehov til veksleren <b>${model.Pmax_veksler.toFixed(1)} kW</b>.</p>
            <p>Brug P-V kurven nedenfor til interaktivt at finde en passende kombination af effekt og volumen.</p>
            <div class="row g-3">
                <div class="col-md-6"><label class="form-label">Indtast tilg√¶ngelig effekt</label><div class="input-group"><input id="userEffekt" type="number" step="0.1" class="form-control" placeholder="f.eks. 35"><span class="input-group-text">kW</span></div></div>
                <div class="col-md-6"><label class="form-label">Indtast √∏nsket volumen</label><div class="input-group"><input id="userVolumen" type="number" class="form-control" placeholder="f.eks. 200"><span class="input-group-text">L</span></div></div>
            </div>`;
    } else {
        metodeA_div.innerHTML = `<p class="text-muted">Metode A kr√¶ver, at du tilf√∏jer tapsteder af typen "Lejlighed".</p>`;
    }

    // 6. R√òRDATA TABEL
    const r√∏rTable = document.getElementById('r√∏rResultTable');
    r√∏rTable.querySelector('thead').innerHTML = `<tr>
        <th>ID/Navn</th>
        <th>Type</th>
        <th>Dim.</th>
        <th>q [l/s]</th>
        <th>v [m/s]</th>
        <th>R√∏rfriktion [Pa/m]</th>
        <th>Fittings [Pa]</th>
        <th>Total [Pa]</th>
        <th>Varmetab [W]</th>
    </tr>`;
    
    let r√∏rTbody = '';
    model.nodes.forEach(n => {
        if((n.type === 'ror_vv' || n.type === 'cirkulation_vv') && n.nom_dim) {
            const flow_ls = n.type === 'ror_vv' ? (n.qd || 0) : (model.circFlows.get(n.id) || 0);
            const d_i = ID[n.material][n.nom_dim] / 1000;
            const area = Math.PI * (d_i / 2) ** 2;
            const velocity = n.L > 0 && area > 0 ? (flow_ls / 1000) / area : 0;
            
            // V√ÜLG DEN KORREKTE TEMPERATUR TIL BEREGNINGEN
            // Freml√∏b = T_v, Retur = Middeltemperatur (T_v - dT/2)
            const temp = n.type === 'ror_vv' ? config.T_v : meanTemp;
            const rho = getWaterDensity(temp);

            // 1. Beregn RENT friktionstab pr. meter (uden till√¶g) - Send temp med!
            // getDP(flow, d, rughed, L, zeta, pct, temp) -> Vi s√¶tter zeta=0 og pct=0
            const dp_pure_friction_total = getDP(flow_ls, d_i, RH[n.material]/1000, n.L, 0, 0, temp);
            const dp_pr_meter = (n.L > 0 && flow_ls > 0.000001) ? (dp_pure_friction_total / n.L) : 0;

            // 2. Beregn Fittings Tab (Zeta + %-Till√¶g)
            // Till√¶gget (fx 25%) beregnes af det rene r√∏rfriktionstab
            const surcharge_loss = dp_pure_friction_total * (config.fittings_pct / 100);
            
            // Beregn dynamisk tryk til Zeta-tab (bruger nu den korrekte densitet)
            const dynamic_pressure = rho * (velocity ** 2) / 2;
            const zeta_loss = (n.zeta_sum || 0) * dynamic_pressure;
            
            const fittings_total = surcharge_loss + zeta_loss;

            // 3. Total Tryktab
            const dp_total_calc = dp_pure_friction_total + fittings_total;
            
            // Advarsler (R√∏d trekant hvis over gr√¶nsen)
            let velocityWarning = '';
            if (n.type === 'ror_vv' && velocity > config.max_v_f) velocityWarning = ' ‚ö†Ô∏è';
            if (n.type === 'cirkulation_vv' && velocity > config.max_v_c) velocityWarning = ' ‚ö†Ô∏è';
            
            let dpWarning = '';
            if (dp_pr_meter > config.max_dp_m) dpWarning = ' ‚ö†Ô∏è';

            r√∏rTbody += `<tr onmouseenter="highlightComponent('${n.id}')" onmouseleave="clearHighlight()">
                <td><b>${getDisplayName(n.id)}</b></td>
                <td>${n.type}</td>
                <td>${n.nom_dim} mm</td>
                <td>${flow_ls.toFixed(3)}</td>
                <td>${velocity.toFixed(2)}${velocityWarning}</td>
                <td>${dp_pr_meter.toFixed(0)}${dpWarning}</td>
                <td>${fittings_total.toFixed(0)}</td>
                <td>${dp_total_calc.toFixed(0)}</td>
                <td>${(n.q_tab||0).toFixed(1)}</td>
            </tr>`;
        }
    });
    r√∏rTable.querySelector('tbody').innerHTML = r√∏rTbody;
    
    // 7. CIRKULATION TABEL
    const cirkTable = document.getElementById('cirkResultTable');
    cirkTable.querySelector('thead').innerHTML = `<tr><th>Streng</th><th>Valgt Ventil</th><th>Varmetab [W]</th><th>Flow [l/h]</th><th>Tryktab [Pa]</th><th>Ventil Œîp [Pa]</th></tr>`;
    let cirkTbody = '';
    let grandTotalFlowLH = 0;

    model.loops.forEach(l => {
        const flowLH = (l.circ_flow || 0) * 3600;
        grandTotalFlowLH += flowLH; 
        
        let valveText = '-';
        let settingText = '-';
        let valveDpDisplay = 0;
        let dpLabel = "Ventil Œîp";
        
        if (l.selectedValve) {
            valveText = l.selectedValve.valveName || l.selectedValve.freseNr || '-'; 
            
            if (l.selectedValve.isStatic) {
                const requiredValveDrop = Math.max(0, model.max_dp_circ - (l.dp_circ_total - l.selectedValve.minDp));
                valveDpDisplay = requiredValveDrop;
                
                const dp_kPa = requiredValveDrop / 1000;
                if (dp_kPa > 0) {
                    const kv_req = 36 * l.circ_flow / Math.sqrt(dp_kPa);
                    settingText = `Kv: ${kv_req.toFixed(2)}`;
                } else {
                    settingText = "√Öben";
                }
                dpLabel = "Indreg. Œîp";
            } else {
                valveDpDisplay = l.selectedValve.minDp || 0;
                settingText = "Auto";
                dpLabel = "Min. Œîp";
            }
        }

        cirkTbody += `<tr data-loop-id="${l.id}" onmouseenter="highlightLoop('${l.id}')" onmouseleave="clearHighlight()">
                      <td><b>${getDisplayName(l.id)}</b></td>
                      <td>${valveText} <br><small class="text-muted">${l.selectedValve ? l.selectedValve.vvsNr : ''}</small></td>
                      <td>${(l.q_tab_tot || 0).toFixed(1)}</td>
                      <td>${flowLH.toFixed(1)}</td>
                      <td>${(l.dp_circ_total || 0).toFixed(0)}</td>
                      <td>
                        <b>${valveDpDisplay.toFixed(0)}</b> <span class="text-muted" style="font-size:0.7em">(${dpLabel})</span>
                        <br><small>${settingText}</small>
                      </td>
                    </tr>`;
    });

    const totalCircFlowM3H = grandTotalFlowLH / 1000;
    cirkTbody += `
        <tr class="table-secondary" style="border-top: 2px solid #dee2e6;">
            <td colspan="3" class="text-end"><b>Samlet Cirkulation:</b></td>
            <td><b>${grandTotalFlowLH.toFixed(1)} l/h</b><br><small>(${totalCircFlowM3H.toFixed(3)} m¬≥/h)</small></td>
            <td colspan="2"></td>
        </tr>
        <tr><td colspan="6" class="text-muted small"><em>OBS: Husk at sammenholde beholdervolumen med cirkulationsflow.</em></td></tr>`;

    cirkTable.querySelector('tbody').innerHTML = cirkTbody;
}


// =================================================================================
// == FUNKTIONER TIL DIAGRAM-VISUALISERING                                        ==
// =================================================================================
function updateDiagramStyles() {
    if (!state.lastModel) return;
    const model = state.lastModel;

    const links = d3.selectAll("#diagram svg .link-freml√∏b, #diagram svg .link-cirkulation_vv");
    
    // Juster tykkelse baseret p√• dimension
    const pipeNodes = Array.from(model.nodes.values()).filter(n => (n.type === 'ror_vv' || n.type === 'cirkulation_vv') && n.nom_dim);
    if (pipeNodes.length > 0) {
        const dimDomain = d3.extent(pipeNodes, n => n.nom_dim);
        if (dimDomain[0] === dimDomain[1]) dimDomain[0] -= 1;
        const thicknessScale = d3.scaleLinear().domain(dimDomain).range([1.5, 8]);
        links.style('stroke-width', d => {
            const node = model.nodes.get(d.target.id);
            return (node && node.nom_dim) ? `${thicknessScale(node.nom_dim)}px` : '1.5px';
        });
    }

    const visMode = document.querySelector('input[name="visMode"]:checked').value;
    const showCritical = document.getElementById('visKritisk').checked;
    
    // Nulstil f√∏rst (dette g√∏r dem bl√•/r√∏de efter CSS standard)
    links.style('stroke', null).style('opacity', null).style('stroke-dasharray', null);

    if (showCritical) {
        highlightCriticalPath();
    } else if (visMode !== 'none') {
        applyColorGradient(visMode);
    } else {
        // --- HER ER DEN VIGTIGE MODEL B LOGIK ---
        // Dette overskriver CSS-farverne med vores Topologi-farver
        links.style('stroke', d => {
            const n = model.nodes.get(d.target.id);
            if (!n) return '#ccc';
            
            // Hvis kategorien mangler (f.eks. hvis analyse ikke er k√∏rt), falder vi tilbage til CSS (null)
            if (!n.category) return null;

            switch (n.category) {
                // VARMT VAND (R√òD)
                case 'main': return '#8b0000';          // M√∏rker√∏d
                case 'distribution': return '#dc3545';  // R√∏d
                case 'connection': return '#f08080';    // Lysr√∏d
                
                // VARM CIRKULATION (R√òD)
                case 'main_return': return '#8b0000';   // M√∏rker√∏d
                case 'return': return '#dc3545';        // R√∏d
                
                // KOLDT VAND (BL√Ö - Forberedt)
                case 'cold_main': return '#00008b';         
                case 'cold_distribution': return '#0d6efd'; 
                case 'cold_connection': return '#89cff0';   
                case 'cold_return': return '#0d6efd';       

                default: return '#ccc';
            }
        })
        .style('stroke-dasharray', d => {
            const n = model.nodes.get(d.target.id);
            if (!n) return null;

            // Stiplet linje for alle retur-typer (Varm og Kold)
            if (['main_return', 'return', 'cold_return'].includes(n.category)) {
                if (n.category === 'cold_return') {
                    return '2, 4'; // Kold: Finprikket
                } else {
                    return '6, 4'; // Varm: Stiplet
                }
            }
            return null; // Solid
        });
    }
    
    updateLegend();

    // Opdater labels (tekst p√• r√∏r)
    const showDim = document.getElementById('visDim').checked;
    const showDpM = document.getElementById('visTryktabLabel').checked;
    const showVel = document.getElementById('visHastighedLabel').checked;
    const showLen = document.getElementById('visLaengde').checked;
    const showFlow = document.getElementById('visFlow').checked;

    d3.select("#diagram svg").selectAll(".link-text").text(d => {
        const n = model.nodes.get(d.target.id);
        if (!n || !(n.type === 'ror_vv' || n.type === 'cirkulation_vv') || !n.nom_dim) return "";        

        const parts = [];
        const flow_ls = n.type === 'ror_vv' ? (n.qd || 0) : (model.circFlows ? (model.circFlows.get(n.id) || 0) : 0);

        if (showDim) parts.push(`${n.nom_dim}mm`);
        if (showLen) parts.push(`${n.L}m`);
        if (showFlow) parts.push(`${flow_ls.toFixed(3)} l/s`);
        if (showVel) {
            const d_i = ID[n.material][n.nom_dim] / 1000;
            const area = Math.PI * (d_i / 2) ** 2;
            const velocity = n.L > 0 && area > 0 ? (flow_ls / 1000) / area : 0;
            parts.push(`${velocity.toFixed(2)} m/s`);
        }
        if (showDpM) {
            const dp_total = n.type === 'ror_vv' ? (n.dp_tap || 0) : (n.dp_circ || 0);
            const dp_pr_meter = n.L > 0 ? dp_total / n.L : 0;
            parts.push(`${dp_pr_meter.toFixed(1)} Pa/m`);
        }
        return parts.join(' | ');
    });
}

function applyColorGradient(mode) {
    const model = state.lastModel;
    let values = [];
    
    model.nodes.forEach(n => {
        if ((n.type === 'ror_vv' || n.type === 'cirkulation_vv') && n.L > 0 && n.nom_dim) {
            let value;
            
            if (mode === 'temp') {
                // Hent temperatur. Hvis den ikke findes, brug T_v (fejlsikring)
                // Vi bruger gennemsnittet af indl√∏b og udl√∏b for at farve r√∏ret
                const t_in = model.nodeTemps ? (model.nodeTemps.get(n.id) || 0) : 0;
                // Estimer t_out til visualisering
                let t_out = t_in;
                // Genberegn lille dt for at f√• pr√¶cis farve
                if (mode === 'temp') {
                     const flow = model.circFlows.get(n.id) || 0;
                     if (flow > 0.0001) {
                         const dt = (n.q_tab || 0) / (flow * 4121);
                         t_out = t_in - dt;
                     }
                }
                value = (t_in + t_out) / 2;
                
                // Skaf v√¶rdier til legende
                if (value > 0) values.push(value);
                n._visValue = value;

            } else {
                // ... (Eksisterende logik for velocity, pressure_drop, heat_loss) ...
                if (mode === 'velocity') {
                    // ... (din eksisterende kode)
                    const flow = n.type === 'ror_vv' ? (n.qd || 0) : (model.circFlows.get(n.id) || 0);
                    const d_i = ID[n.material][n.nom_dim];
                    value = (flow / 1000) / (Math.PI * (d_i / 2000) ** 2);
                } else if (mode === 'pressure_drop') {
                    const dp = n.type === 'ror_vv' ? (n.dp_tap || 0) : (n.dp_circ || 0);
                    value = dp / n.L;
                } else if (mode === 'heat_loss') {
                    value = (n.q_tab || 0) / n.L;
                }
                n._visValue = value;
                if (isFinite(value)) values.push(value);
            }
        }
    });

    if (values.length === 0) return;
    
    let colorScale;
    
    if (mode === 'temp') {
        // Speciel farveskala for temperatur: R√∏d (Varm) -> Bl√• (Kold)
        // Vi s√¶tter dom√¶net fra T_v ned til T_v - dT - buffer
        // F.eks. 55 -> 48 grader.
        const maxTemp = d3.max(values) || 55;
        const minTemp = d3.min(values) || 45;
        
        // Turbo er god, men m√•ske omvendt (R√∏d h√∏j, Bl√• lav)
        colorScale = d3.scaleSequential(d3.interpolateTurbo).domain([minTemp, maxTemp]); 
    } else {
        const domain = d3.extent(values);
        if (domain[0] === domain[1]) { domain[0] -= 0.1; domain[1] += 0.1; }
        colorScale = d3.scaleSequential(d3.interpolateTurbo).domain(domain);
    }
    
    d3.selectAll("#diagram svg .link-freml√∏b, #diagram svg .link-cirkulation_vv")
      .style('stroke', d => {
          const node = model.nodes.get(d.target.id);
          return node && isFinite(node._visValue) ? colorScale(node._visValue) : '#ccc';
      });
}

function highlightCriticalPath() {
    const criticalPath = state.lastModel.criticalPath;
    if (!criticalPath) return;

    d3.selectAll("#diagram svg .link-freml√∏b, #diagram svg .link-cirkulation_vv")
        .each(function(d) {
            const link = d3.select(this);
            const isCritical = criticalPath.has(d.source.id) && criticalPath.has(d.target.id);
            if (isCritical) {
                link.style('stroke', '#007bff').style('stroke-width', '4px').style('opacity', 1); // RETTELSE: .attr -> .style
            } else {
                link.style('opacity', 0.2);
            }
        });
}

function updateLegend() {
    const legendDiv = document.getElementById('diagram-legend');
    if (!document.getElementById('visLegend').checked || !state.lastModel) {
        legendDiv.style.display = 'none';
        return;
    }

    // Justeringer til legendens stil
    legendDiv.style.display = 'block';
    legendDiv.style.position = 'absolute';
    legendDiv.style.bottom = '10px';
    legendDiv.style.left = '10px'; // Flyttet til venstre
    legendDiv.style.width = '25%';  // Sat til 1/4 bredde
    legendDiv.style.fontSize = '0.8rem';
    legendDiv.classList.add('p-2', 'bg-light', 'border', 'rounded');


    const visMode = document.querySelector('input[name="visMode"]:checked').value;
    const showCritical = document.getElementById('visKritisk').checked;

    let html = '';

    if (showCritical) {
        html = `<div><span style="background-color:#007bff; display:inline-block; width:20px; height:10px; margin-right:5px; vertical-align: middle;"></span> Kritisk Streng</div>`;
    } else if (visMode !== 'none') {
        const nodesWithValues = Array.from(state.lastModel.nodes.values()).filter(n => n._visValue !== undefined && isFinite(n._visValue));
        if (nodesWithValues.length > 0) {
            const minVal = d3.min(nodesWithValues, n => n._visValue);
            const maxVal = d3.max(nodesWithValues, n => n._visValue);
            const units = { velocity: 'm/s', pressure_drop: 'Pa/m', heat_loss: 'W/m', temp: '¬∞C'};
            html = `
                <div class="d-flex justify-content-between">
                    <span>${minVal.toFixed(2)}</span>
                    <span><b>${units[visMode]}</b></span>
                    <span>${maxVal.toFixed(2)}</span>
                </div>
                <div style="height:10px; background: linear-gradient(to right, ${d3.interpolateTurbo(0)}, ${d3.interpolateTurbo(0.25)}, ${d3.interpolateTurbo(0.5)}, ${d3.interpolateTurbo(0.75)}, ${d3.interpolateTurbo(1)}); border-radius: 2px;"></div>
            `;
        }
    } else {
        legendDiv.style.display = 'none';
    }
    legendDiv.innerHTML = html;
}


// =================================================================================
// == NY BEREGNINGSMOTOR: GLOBAL OPTIMERING                                       ==
// =================================================================================

function beregnGlobalOptimering(config) {
    console.group("üöÄ GLOBAL OPTIMERING START (VV)");
    const model = buildModel(config);
    
    model.loops.forEach(l => l.path = getPath(model, l.startNodeId, l.endNodeId));
    analyzeSystemTopology(model);

    // ... (Constraint logik u√¶ndret) ...
    config.globalConstraintType = document.querySelector('input[name="globalConstraint"]:checked').value;
    console.log(`Constraint Type: ${config.globalConstraintType}`);

    // Nulstil til mindste dimensioner
    model.nodes.forEach(n => {
        if (n.type === 'ror_vv' || n.type === 'cirkulation_vv') {
            const sortedDims = Object.keys(ID[n.material]).map(Number).sort((a,b)=>a-b);
            n.nom_dim = sortedDims[0];
        }
    });

    let iterations = 0;
    const maxIterations = 10000;
    let optimized = false;
    let finalLocalFailures = [];
    let finalGlobalFailures = [];

    while (iterations < maxIterations) {
        // KALD DE NYE _VV FUNKTIONER
        calculateQd_VV(model);
        calculatePressureDrop_VV(model.tree, 'dp_tap', 'qd', config);
        
        const localFailures = findLocalFailures_VV(model, config);
        const globalFailures = findFailingTapPoints_VV(model, config);
        
        if (iterations === 0 || iterations % 500 === 0 || localFailures.length === 0) {
             console.log(`Iter ${iterations}: Lokale=${localFailures.length}, Globale=${globalFailures.length}`);
        }

        if (localFailures.length === 0 && globalFailures.length === 0) {
            optimized = true;
            break; 
        }
        
        finalLocalFailures = localFailures;
        finalGlobalFailures = globalFailures;

        let pipeToUpgradeId;

        if (localFailures.length > 0) {
            pipeToUpgradeId = localFailures[0].id;
        } else {
            const worstTap = globalFailures[0];
            const worstPath = getPathToTapPoint(model, worstTap.id);
            pipeToUpgradeId = findWorstOffendingPipe_VV(model, worstPath);
        }

        if (pipeToUpgradeId) {
            const pipeNode = model.nodes.get(pipeToUpgradeId);
            const success = upgradePipeDimension(pipeNode);
            if (!success) break; 
        } else {
            break; 
        }
        iterations++;
    }

    model.optimizationInfo = { converged: optimized, iterations: iterations, remainingErrors: finalLocalFailures.length + finalGlobalFailures.length };

    // Afsluttende beregninger (VV)
    const pressureDropResult = findMaxPathDp_VV(model.tree, config);
    model.max_dp_tapning = pressureDropResult.max_dp;
    model.criticalPath = new Set(pressureDropResult.path);
    
    // Cirkulations loop (VV)
    for (let i = 0; i < 3; i++) {
        calculateInsulation(model, config);
        calculateHeatLoss_VV(model, config);
        calculateCirculationFlows_VV(model, config); // Integreret loop
    }
    
    calculateCirculationDP_VV(model, config);
    calculateBeholder(model);

    console.groupEnd();
    return model;
}

function findLocalFailures_VV(model, config) {
    const failures = [];
    const temp = config.T_v;
    model.nodes.forEach(n => {
        if (n.type === 'ror_vv' && n.nom_dim && n.qd > 0) {
            const d_i = ID[n.material][n.nom_dim] / 1000;
            const v = (n.qd / 1000) / (Math.PI * Math.pow(d_i / 2, 2));
            const dp_m = getDP(n.qd, d_i, RH[n.material] / 1000, 1, 0, 0, temp); // Rent r√∏rtab

            if (config.globalConstraintType === 'velocity' && v > config.max_v_f) {
                failures.push({ id: n.id, value: v, type: 'velocity' });
            } else if (config.globalConstraintType === 'pressure_drop' && dp_m > config.max_dp_m) {
                failures.push({ id: n.id, value: dp_m, type: 'pressure_drop' });
            }
        }
    });
    return failures.sort((a, b) => b.value - a.value);
}

// --- Hj√¶lpefunktioner til Global Optimering ---

function findFailingTapPoints_VV(model, config) {
    const failingPoints = [];
    model.nodes.forEach(n => {
        if (n.type === 'tapsted') {
            const path = getPathToTapPoint(model, n.id);
            const totalDp = path.reduce((sum, nodeId) => sum + (model.nodes.get(nodeId).dp_tap || 0), 0);
            const remainingPressure = config.pln - totalDp;
            if (remainingPressure < config.min_tap_tryk) {
                failingPoints.push({ id: n.id, pressure: remainingPressure });
            }
        }
    });
    return failingPoints.sort((a, b) => a.pressure - b.pressure);
}

function getPathToTapPoint(model, tapPointId) {
    const path = [];
    let current = model.nodes.get(tapPointId);
    while(current && current.id !== 'Beholder') {
        path.push(current.id);
        current = model.nodes.get(current.parentId);
    }
    return path.reverse();
}

function findWorstOffendingPipe_VV(model, path) {
    let worstPipeId = null;
    let maxPaPerMeter = -1;
    path.forEach(nodeId => {
        const n = model.nodes.get(nodeId);
        if (n.type === 'ror_vv' && n.L > 0) {
            const dp_pr_meter = (n.dp_tap || 0) / n.L;
            if (dp_pr_meter > maxPaPerMeter) {
                maxPaPerMeter = dp_pr_meter;
                worstPipeId = n.id;
            }
        }
    });
    return worstPipeId;
}

function upgradePipeDimension(pipeNode) {
    const mat = pipeNode.material;
    const sortedDims = Object.keys(ID[mat]).map(Number).sort((a, b) => a - b);
    const currentIndex = sortedDims.indexOf(pipeNode.nom_dim);

    if (currentIndex < sortedDims.length - 1) {
        pipeNode.nom_dim = sortedDims[currentIndex + 1];
        return true; // Opgradering lykkedes
    }
    return false; // Allerede p√• st√∏rste dimension
}


// =================================================================================
// == FUNKTIONER TIL RAPPORTGENERERING                                            ==
// =================================================================================

/**
 * Starter rapport-genereringen.
 * Tager snapshots af diagrammet i forskellige tilstande og √•bner et nyt vindue.
 */
function showCalculationReport() {
    if (!state.lastModel || !state.lastConfig) {
        alert('Du skal f√∏rst k√∏re en beregning for at kunne generere en rapport.');
        return;
    }

    // Hj√¶lpefunktion til at hente SVG som en streng
    const getSVG = () => {
        const svgElement = document.querySelector("#diagram svg");
        if (!svgElement) return "";
        
        // Klon elementet for ikke at √∏del√¶gge det levende diagram
        const clone = svgElement.cloneNode(true);
        
        // S√¶t faste dimensioner til rapporten
        clone.setAttribute("width", "100%");
        clone.removeAttribute("height"); 
        clone.style.maxHeight = "550px";
        clone.style.display = "block";
        clone.style.margin = "0 auto";
        
        return new XMLSerializer().serializeToString(clone);
    };

    // GEM NUV√ÜRENDE VISNINGS-TILSTAND
    const originalVisMode = document.querySelector('input[name="visMode"]:checked').value;
    const originalVisKritisk = document.getElementById('visKritisk').checked;

    // --- SNAPSHOT 1: STANDARD TOPOLOGI (Farver efter kategori) ---
    document.getElementById('visKritisk').checked = false;
    // V√¶lg "Ingen" for at se r√∏rkategorier (Hoved/Fordeling/Kobling)
    const radNone = document.querySelector('input[value="none"]');
    if(radNone) radNone.checked = true;
    updateDiagramStyles(); 
    const svgStandard = getSVG();

    // --- SNAPSHOT 2: TEMPERATUR FORDELING ---
    const radTemp = document.querySelector('input[value="temp"]');
    if(radTemp) radTemp.checked = true;
    updateDiagramStyles();
    const svgTemp = getSVG();

    // --- SNAPSHOT 3: KRITISK VEJ ---
    if(radNone) radNone.checked = true; // Nulstil farver f√∏rst
    document.getElementById('visKritisk').checked = true;
    updateDiagramStyles();
    const svgCritical = getSVG();

    // GENDAN OPRINDELIG TILSTAND P√Ö SK√ÜRMEN
    const origRad = document.querySelector(`input[value="${originalVisMode}"]`);
    if(origRad) origRad.checked = true;
    document.getElementById('visKritisk').checked = originalVisKritisk;
    updateDiagramStyles();

    // Generer selve HTML'en
    const reportHTML = generateReportHTML(state.lastModel, state.lastConfig, svgStandard, svgTemp, svgCritical);
    
    // √Öbn i nyt vindue
    const reportWindow = window.open('', '_blank');
    if (reportWindow) {
        reportWindow.document.open();
        reportWindow.document.write(reportHTML);
        reportWindow.document.close();
    } else {
        alert("Kunne ikke √•bne rapport-vinduet. Tjek din pop-up blokker.");
    }
}

/**
 * GENERER RAPPORT HTML (Med Kote-detaljer for Kritisk Vej)
 */
function generateReportHTML(model, config, svgTopo, svgTemp, svgCrit) {
    const reportDate = new Date().toLocaleDateString('da-DK', { year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' });
    const projTitle = config.projectName || 'Ikke navngivet projekt';

    // --- HJ√ÜLPERE (Overs√¶ttelse) ---
    const translateCat = (cat) => {
        const map = {
            'main': 'Hovedledning (Frem)',
            'distribution': 'Fordelingsledn. (Frem)',
            'connection': 'Koblingsledn. (Frem)',
            'main_return': 'Hovedledning (Retur)',
            'return': 'Returledning',
            'cold_main': 'Koldt Vand (Hoved)',
            'cold_distribution': 'Koldt Vand (Fordeling)',
            'cold_connection': 'Koldt Vand (Kobling)'
        };
        return map[cat] || 'R√∏r';
    };

    // --- LEGENDER ---
    const renderTopoLegend = () => `
        <div class="legend-container">
            <div class="legend-item"><span class="line solid" style="border-color:#8b0000"></span> Hovedledning (Frem)</div>
            <div class="legend-item"><span class="line solid" style="border-color:#dc3545"></span> Fordelingsledn.</div>
            <div class="legend-item"><span class="line dashed" style="border-color:#a71d2a"></span> Returledning</div>
            <div class="legend-item"><span class="dot" style="background-color:#198754"></span> Tapsted</div>
            <div class="legend-item"><span class="dot" style="background-color:#6f42c1; border-radius:0; transform:rotate(45deg); width:8px; height:8px;"></span> Ventil</div>
        </div>`;

    const renderTempLegend = () => {
        const temps = Array.from(model.nodeTemps ? model.nodeTemps.values() : []);
        const maxT = temps.length > 0 ? Math.max(...temps) : config.T_v;
        const minT = temps.length > 0 ? Math.min(...temps) : (config.T_v - config.dT);
        
        return `
        <div class="legend-container" style="flex-direction:column; align-items:center;">
            <div style="width:300px; height:15px; background: linear-gradient(to right, #3060cf, #25a89e, #68b538, #d4a822, #d13224); border-radius:3px; margin-bottom:5px;"></div>
            <div style="width:300px; display:flex; justify-content:space-between; font-size:0.8em; color:#666;">
                <span>${minT.toFixed(1)} ¬∞C (Koldest)</span>
                <span>${maxT.toFixed(1)} ¬∞C (Varmest)</span>
            </div>
        </div>`;
    };

    // --- KRITISK STRENG TABEL (MED KOTE DETALJER) ---
    const generateCriticalPathTable = () => {
        if (!model.criticalPath || model.criticalPath.size === 0) return '<p><i>Ingen kritisk vej fundet.</i></p>';

        // Find slut-noden (tapstedet)
        let endNode = null;
        for (const nodeId of model.criticalPath) {
            const n = model.nodes.get(nodeId);
            if (n && n.type === 'tapsted') { endNode = n; break; }
        }
        if (!endNode) return '<p><i>Kunne ikke identificere slutpunkt.</i></p>';

        // Rekonstruer stien bagl√¶ns
        const path = [];
        let current = endNode;
        while (current && current.id !== 'Beholder') {
            path.unshift(current);
            current = model.nodes.get(current.parentId);
        }
        
        // Beregn Geod√¶tisk Data til visning
        const koteSupply = config.forsyningens_kote || 0;
        const koteTap = endNode.kote || 0;
        const liftHeight = koteTap - koteSupply;
        const RHO = 985, G = 9.82;
        const totalGeoDp = liftHeight * RHO * G;
        
        // NYT: Info-boks om koter
        let html = `<div style="margin-bottom:15px; padding:10px; background-color:#f8f9fa; border:1px solid #e9ecef; border-radius:4px; font-size:0.9em;">
            <h4 style="margin-top:0; margin-bottom:5px; color:#2c3e50;">Geod√¶tisk L√∏fteh√∏jde (Detaljer)</h4>
            <table style="margin-bottom:0; background:transparent;">
                <tr><td style="padding:2px 10px 2px 0; border:none;">Kote Kritisk Tapsted:</td><td style="padding:2px 0; border:none;"><b>${koteTap} m</b></td></tr>
                <tr><td style="padding:2px 10px 2px 0; border:none;">Kote Forsyning:</td><td style="padding:2px 0; border:none;"><b>${koteSupply} m</b></td></tr>
                <tr><td style="padding:2px 10px 2px 0; border:none;">H√∏jdeforskel (L√∏fteh√∏jde):</td><td style="padding:2px 0; border:none;"><b>${liftHeight} m</b></td></tr>
                <tr><td style="padding:2px 10px 2px 0; border:none; color:#666;"><i>Beregning (œÅ¬∑g¬∑h):</i></td><td style="padding:2px 0; border:none; color:#666;"><i>${liftHeight} m √ó 985 kg/m¬≥ √ó 9,82 m/s¬≤ ‚âà <b>${totalGeoDp.toFixed(0)} Pa</b></i></td></tr>
            </table>
        </div>`;

        html += '<table class="critical-path-table" style="font-size:0.85em;">';
        html += '<thead><tr><th>Komponent</th><th>Dim.</th><th>L√¶ngde</th><th>Flow [l/s]</th><th>Hast. [m/s]</th><th>Œîp Friktion [Pa]</th><th>Œîp Geo. [Pa]</th><th>Œîp Total [Pa]</th></tr></thead><tbody>';
        
        let sumDpFriction = 0;

        path.forEach(n => {
            if (n.type === 'ror_vv') {
                const flow = n.qd || 0;
                const d_i = ID[n.material][n.nom_dim] / 1000;
                const v = (flow / 1000) / (Math.PI * (d_i / 2) ** 2);
                const dp = n.dp_tap || 0;
                sumDpFriction += dp;
                
                html += `<tr>
                    <td>${n.name || n.id}</td>
                    <td>${n.material} ${n.nom_dim}</td>
                    <td>${n.L} m</td>
                    <td>${flow.toFixed(3)}</td>
                    <td>${v.toFixed(2)}</td>
                    <td>${dp.toFixed(0)}</td>
                    <td>-</td>
                    <td>${dp.toFixed(0)}</td>
                </tr>`;
            } else if (n.type === 'tapsted') {
                html += `<tr style="background-color:#e8f5e9;">
                    <td><b>${n.name || n.id}</b> (Tapsted)</td>
                    <td>-</td>
                    <td>-</td>
                    <td>${n.qf.toFixed(2)}</td>
                    <td>-</td>
                    <td>-</td>
                    <td><b>${totalGeoDp.toFixed(0)}</b></td>
                    <td><b>${totalGeoDp.toFixed(0)}</b></td>
                </tr>`;
            }
        });

        html += `<tr style="background-color:#2c3e50; color:white;">
            <td colspan="5"><b>TOTAL (Kritisk Streng)</b></td>
            <td><b>${sumDpFriction.toFixed(0)}</b></td>
            <td><b>${totalGeoDp.toFixed(0)}</b></td>
            <td><b>${(sumDpFriction + totalGeoDp).toFixed(0)}</b></td>
        </tr>`;
        html += '</tbody></table>';
        return html;
    };

    // --- STYKLISTE (BOM) ---
    const generateBOM = () => {
        const bom = {}; 
        model.nodes.forEach(n => {
            if ((n.type === 'ror_vv' || n.type === 'cirkulation_vv') && n.material && n.nom_dim) {
                if (!bom[n.material]) bom[n.material] = {};
                if (!bom[n.material][n.nom_dim]) bom[n.material][n.nom_dim] = 0;
                bom[n.material][n.nom_dim] += (n.L || 0);
            }
        });
        if (Object.keys(bom).length === 0) return '<p><i>Ingen r√∏r fundet.</i></p>';
        let html = '<table class="bom-table"><thead><tr><th>Materiale</th><th>Dimension</th><th>Total L√¶ngde [m]</th></tr></thead><tbody>';
        Object.keys(bom).sort().forEach(mat => {
            Object.keys(bom[mat]).sort((a,b) => parseFloat(a) - parseFloat(b)).forEach(dim => {
                html += `<tr><td>${mat}</td><td>${dim} mm</td><td><b>${bom[mat][dim].toFixed(1)}</b></td></tr>`;
            });
        });
        html += '</tbody></table>';
        return html;
    };

    // --- ISOLERINGS SPECIFIKATION ---
    const generateInsulationTable = () => {
        const locations = {
            'heated': { title: 'Indvendig i opvarmet rum', data: [] },
            'unheated': { title: 'Indvendig i uopvarmet rum', data: [] },
            'outside': { title: 'Udvendig / I jord', data: [] }
        };

        model.nodes.forEach(n => {
            if ((n.type === 'ror_vv' || n.type === 'cirkulation_vv') && n.material && n.nom_dim) {
                const locKey = n.location || 'heated';
                const catName = translateCat(n.category);
                const key = `${catName}|${n.material}|${n.nom_dim}|${n.insulationClass}|${n.insulationThickness}`;
                
                let entry = locations[locKey].data.find(e => e.key === key);
                if (!entry) {
                    entry = {
                        key: key,
                        category: catName,
                        material: n.material,
                        dim: n.nom_dim,
                        class: n.insulationClass ? `Kl. ${n.insulationClass}` : 'Ingen (Kl. 0)',
                        thickness: n.insulationThickness,
                        len: 0
                    };
                    locations[locKey].data.push(entry);
                }
                entry.len += (n.L || 0);
            }
        });

        let html = '';
        for (const [locKey, locObj] of Object.entries(locations)) {
            if (locObj.data.length === 0) continue;
            locObj.data.sort((a, b) => {
                if (a.category !== b.category) return a.category.localeCompare(b.category);
                return a.dim - b.dim;
            });
            html += `<h4>${locObj.title}</h4>`;
            html += '<table class="bom-table"><thead><tr><th>R√∏rtype / Anvendelse</th><th>Materiale</th><th>Dim.</th><th>Isoleringsklasse</th><th>Tykkelse</th><th>L√¶ngde</th></tr></thead><tbody>';
            locObj.data.forEach(d => {
                const th = d.thickness > 0 ? `<b>${d.thickness} mm</b>` : '<span style="color:#999">-</span>';
                html += `<tr><td>${d.category}</td><td>${d.material}</td><td>${d.dim} mm</td><td>${d.class}</td><td>${th}</td><td>${d.len.toFixed(1)} m</td></tr>`;
            });
            html += '</tbody></table>';
        }
        return html || '<p><i>Ingen isoleringsdata.</i></p>';
    };

    // --- CIRKULATIONS TABEL ---
    const generateCircTable = () => {
        let html = '<table><thead><tr><th>Streng ID</th><th>Ventil Type</th><th>VVS Nr.</th><th>Flow [l/h]</th><th>Ventil Œîp [kPa]</th><th>Indstilling</th></tr></thead><tbody>';
        model.loops.forEach(l => {
            let valveName = '-', vvsNr = '-', setting = '-', dpVal = 0;
            if (l.selectedValve) {
                valveName = l.selectedValve.valveName || l.selectedValve.freseNr || 'Ukendt';
                vvsNr = l.selectedValve.vvsNr || '-';
                
                if (l.selectedValve.isStatic) {
                    const requiredValveDrop = Math.max(0, model.max_dp_circ - (l.dp_circ_total - l.selectedValve.minDp));
                    dpVal = requiredValveDrop / 1000;
                    if (dpVal > 0) {
                        const kv_req = 36 * l.circ_flow / Math.sqrt(dpVal);
                        setting = `<b>Kv ${kv_req.toFixed(2)}</b>`;
                    } else setting = '√Öben';
                } else {
                    dpVal = (l.selectedValve.minDp || 0) / 1000; 
                    setting = 'Auto';
                }
            }
            html += `<tr><td>${l.name || l.id}</td><td>${valveName}</td><td>${vvsNr}</td><td>${(l.circ_flow * 3600).toFixed(1)}</td><td>${dpVal.toFixed(1)}</td><td>${setting}</td></tr>`;
        });
        html += '</tbody></table>';
        return html;
    };

    // --- REPORT HTML TEMPLATE ---
    return `
        <!DOCTYPE html>
        <html lang="da">
        <head>
            <meta charset="UTF-8">
            <title>Brugsvandsrapport: ${projTitle}</title>
            <style>
                body { font-family: 'Segoe UI', Helvetica, Arial, sans-serif; line-height: 1.5; color: #333; max-width: 900px; margin: 0 auto; padding: 40px; background: #fff; }
                h1 { color: #2c3e50; border-bottom: 2px solid #2c3e50; padding-bottom: 10px; margin-bottom: 20px; }
                h2 { color: #0d6efd; margin-top: 40px; border-bottom: 1px solid #eee; padding-bottom: 5px; page-break-after: avoid; }
                h3 { color: #555; font-size: 1.1em; margin-top: 25px; page-break-after: avoid; }
                h4 { font-size: 0.95em; margin-bottom: 5px; margin-top: 15px; color: #666; }
                
                table { width: 100%; border-collapse: collapse; margin-bottom: 15px; font-size: 0.9rem; }
                th, td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }
                th { background-color: #f8f9fa; font-weight: 600; color: #444; }
                tr:nth-child(even) { background-color: #fcfcfc; }
                
                .info-box { background: #f8f9fa; padding: 20px; border-radius: 5px; margin-bottom: 30px; border: 1px solid #e9ecef; }
                .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; }
                
                .diagram-box { border: 1px solid #ccc; padding: 10px; margin-bottom: 5px; background: #fff; text-align: center; }
                .legend-container { display: flex; justify-content: center; gap: 15px; font-size: 0.8rem; color: #555; margin-top: 5px; flex-wrap: wrap; }
                .legend-item { display: flex; align-items: center; gap: 5px; }
                .line { width: 20px; height: 0; border-top-width: 2px; }
                .solid { border-top-style: solid; }
                .dashed { border-top-style: dashed; }
                .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
                
                .status-ok { color: #198754; font-weight: bold; }
                .status-fail { color: #dc3545; font-weight: bold; }
                
                .checklist p { margin-bottom: 15px; }
                .footer { margin-top: 50px; font-size: 0.8em; text-align: center; color: #999; border-top: 1px solid #eee; padding-top: 20px; }
                
                @media print { 
                    body { padding: 0; } 
                    .no-print { display: none; } 
                    .diagram-box, table { break-inside: avoid; } 
                    h2 { break-after: avoid; }
                }
            </style>
        </head>
        <body>
            <div class="no-print" style="text-align:right; margin-bottom:20px;">
                <button onclick="window.print()" style="padding:10px 20px; background:#0d6efd; color:white; border:none; cursor:pointer; border-radius:4px; font-weight:bold;">üñ®Ô∏è Udskriv / PDF</button>
            </div>

            <h1>Dimensioneringsrapport</h1>
            <div style="display:flex; justify-content:space-between; align-items:baseline; border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 20px;">
                <div style="font-size:1.2em; color:#555;">Projekt: <strong>${projTitle}</strong></div>
                <div style="color:#777;">Dato: ${reportDate}</div>
            </div>

            <div class="info-box">
                <div class="grid-2">
                    <div>
                        <h3>Designkriterier & Foruds√¶tninger</h3>
                        <table style="background:transparent; border:none;">
                            <tr><td style="border:none; padding:2px 0;"><strong>Temperaturkrav (DS 439):</strong></td><td style="border:none; padding:2px 0;"></td></tr>
                            <tr><td style="border:none; padding:2px 0;">Freml√∏bstemperatur:</td><td style="border:none; padding:2px 0;">${config.T_v} ¬∞C</td></tr>
                            <tr><td style="border:none; padding:2px 0;">Min. Returtemperatur:</td><td style="border:none; padding:2px 0;">${config.T_v - config.dT} ¬∞C (ŒîT = ${config.dT} K)</td></tr>
                            <tr><td style="border:none; padding:10px 0 2px 0;"><strong>Till√¶g (Sikkerhed):</strong></td><td style="border:none; padding:10px 0 2px 0;"></td></tr>
                            <tr><td style="border:none; padding:2px 0;">Tryktab Fittings:</td><td style="border:none; padding:2px 0;"><b>+${config.fittings_pct} %</b> (af r√∏rtab)</td></tr>
                            <tr><td style="border:none; padding:2px 0;">Varmetab (Kuldebroer):</td><td style="border:none; padding:2px 0;"><b>+${config.heat_loss_pct} %</b> (af isolering)</td></tr>
                            <tr><td style="border:none; padding:2px 0;">Isolering (Lambda):</td><td style="border:none; padding:2px 0;">${config.lambda} W/m¬∑K</td></tr>
                        </table>
                    </div>
                    <div>
                        <h3>Resultat Opsummering</h3>
                        <table style="background:transparent; border:none;">
                            <tr><td style="border:none; padding:2px 0;">Kritisk Tryktab:</td><td style="border:none; padding:2px 0;">${(model.max_dp_tapning / 1000).toFixed(1)} kPa</td></tr>
                            <tr><td style="border:none; padding:2px 0;">Resttryk v/tapsted:</td><td style="border:none; padding:2px 0;">${((config.pln - model.max_dp_tapning) / 1000).toFixed(1)} kPa</td></tr>
                            <tr><td style="border:none; padding:2px 0;">Status:</td><td style="border:none; padding:2px 0;" class="${(config.pln - model.max_dp_tapning) >= config.min_tap_tryk ? 'status-ok' : 'status-fail'}">${(config.pln - model.max_dp_tapning) >= config.min_tap_tryk ? 'GODKENDT' : 'IKKE GODKENDT'}</td></tr>
                            <tr><td style="border:none; padding:10px 0 2px 0;"><strong>Cirkulationspumpe:</strong></td><td style="border:none; padding:10px 0 2px 0;"></td></tr>
                            <tr><td style="border:none; padding:2px 0;">Samlet Flow:</td><td style="border:none; padding:2px 0;"><b>${(model.loops.reduce((s, l) => s + l.circ_flow, 0) * 3600).toFixed(1)} l/h</b></td></tr>
                            <tr><td style="border:none; padding:2px 0;">L√∏fteh√∏jde (H):</td><td style="border:none; padding:2px 0;"><b>${(model.max_dp_circ / 1000).toFixed(1)} kPa</b></td></tr>
                            <tr><td style="border:none; padding:2px 0;">L√∏fteh√∏jde (mVs):</td><td style="border:none; padding:2px 0;">${(model.max_dp_circ / (985 * 9.82)).toFixed(2)} m</td></tr>
                        </table>
                    </div>
                </div>
            </div>

            <h2>1. Systemoversigt & Topologi</h2>
            <div class="diagram-box">${svgTopo}</div>
            ${renderTopoLegend()}

            <div style="page-break-before: always;"></div>

            <h2>2. Temperatur Dokumentation</h2>
            <p>Viser temperaturfaldet i systemet ved dimensionerende drift. Dokumenterer at min. 50¬∞C overholdes i alle returl√∏b jf. DS 439.</p>
            <div class="diagram-box">${svgTemp}</div>
            ${renderTempLegend()}

            <h2>3. Kritisk Vej</h2>
            <p>Markering af den hydraulisk mest kritiske rute, der bestemmer det n√∏dvendige forsyningstryk.</p>
            <div class="diagram-box">${svgCrit}</div>
            
            <p>Detaljeret beregning af tryktabet frem til det kritiske tapsted:</p>
            ${generateCriticalPathTable()}

            <div style="page-break-before: always;"></div>

            <h2>4. Indregulering af Cirkulation</h2>
            <p>N√∏dvendig indstilling af strengreguleringsventiler for at sikre hydraulisk balance og temperaturkrav.</p>
            ${generateCircTable()}
            <p style="font-size:0.85em; color:#666;">
                <em>* <strong>Kv</strong> angiver den n√∏dvendige √•bning for statiske ventiler. Se datablad for omregning til omdrejninger.<br>
                * <strong>Auto</strong> angiver dynamiske ventiler, hvor flowet styres automatisk, s√• l√¶nge min. differenstryk er til stede.</em>
            </p>

            <h2>5. Isolerings-specifikation (DS 452)</h2>
            <p>Oversigt over isoleringstykkelser fordelt p√• placering og dimension. Varmetab er beregnet inklusiv till√¶g p√• +${config.heat_loss_pct}% for kuldebroer/b√¶ringer.</p>
            ${generateInsulationTable()}

            <h2>6. Materialeliste</h2>
            ${generateBOM()}

            <div style="page-break-before: always;"></div>

            <h2>7. Aflevering, Pr√∏vning & Drift</h2>
            <div class="checklist">
                <p><strong>1. F√∏rstegangs p√•fyldning og gennemskylning</strong><br>
                Inden ibrugtagning skal installationen fyldes langsomt med drikkevand og udluftes grundigt ved alle tapsteder. Herefter skal installationen gennemskylles i henhold til DS 439 pkt. 10.7 for at fjerne urenheder, hj√¶lpestoffer og evt. sp√•ner fra r√∏rsk√¶ring.</p>
                
                <p><strong>2. T√¶thedspr√∏vning (Trykpr√∏vning)</strong><br>
                Installationen skal t√¶thedspr√∏ves jf. DS 439 kapitel 10 f√∏r isolering og indd√¶kning.
                <ul>
                    <li>Pr√∏vningstrykket skal v√¶re mindst 1,5 x driftstrykket, dog mindst 1000 kPa (10 bar), medmindre lavere tryk er foreskrevet for specifikke komponenter.</li>
                    <li>Trykket skal holdes i mindst 2 timer (ved metalr√∏r) eller iht. procedure for plastr√∏r, uden trykfald.</li>
                    <li>T√¶thedspr√∏vningsrapport skal udfyldes og vedl√¶gges KS-materialet.</li>
                </ul>
                </p>

                <p><strong>3. Indregulering</strong><br>
                Cirkulationssystemet skal indreguleres for at sikre korrekt temperaturfordeling.
                <ul>
                    <li><strong>Cirkulationspumpe:</strong> Indstilles til konstanttryk eller proportionaltryk svarende til det beregnede pumpetryk (${(model.max_dp_circ/1000).toFixed(1)} kPa).</li>
                    <li><strong>Ventiler:</strong> Alle strengreguleringsventiler indstilles til de v√¶rdier, der fremg√•r af tabellen i afsnit 4.</li>
                    <li><strong>Kontrolm√•ling:</strong> Det anbefales at kontrollere returtemperaturen ved hver strengs afslutning (skal v√¶re min. ${config.T_v - config.dT} ¬∞C).</li>
                </ul>
                </p>

                <p><strong>4. Dokumentation & Drift</strong><br>
                Ved aflevering skal der foreligge en drifts- og vedligeholdelsesvejledning (D&V), der indeholder:
                <ul>
                    <li>Oversigt over komponenter (pumper, ventiler, vekslere) med datablade.</li>
                    <li>Plan for motionering af ventiler (typisk 1-2 gange √•rligt).</li>
                    <li>Plan for rensning af filtre og perlatorer.</li>
                    <li>Angivelse af set-punkter for temperatur (Frem: ${config.T_v}¬∞C).</li>
                </ul>
                </p>
            </div>

            <div class="footer">
                Beregning udf√∏rt jf. DS 439:2024 (Vandinstallationer) og DS 452 (Teknisk Isolering).<br>
                Genereret af Varmt Brugsvand Tool v0.17
            </div>
        </body>
        </html>
    `;
}

// =================================================================================
// == FUNKTIONER TIL BEHOLDERBEREGNING (3 METODER)                               ==
// =================================================================================

/**
 * Styrer hvilken sektion af inputfelter, der vises, baseret p√• valg af metode.
 */
function toggleBeholderMetode() {
    // Skjul alle inputs
    document.querySelectorAll('.beholder-metode').forEach(div => div.style.display = 'none');
    
    // Find den valgte metode
    const valgElement = document.querySelector('input[name="beholderMetode"]:checked');
    if (!valgElement) return;
    const valg = valgElement.value;
    
    // Vis de relevante inputs
    const inputDiv = document.getElementById(`metode${valg}_inputs`);
    if (inputDiv) inputDiv.style.display = 'block';

    // --- TJEK FOR METODE A ADVARSEL ---
    const warningDiv = document.getElementById('metodeA_warning');
    if (valg === 'A' && warningDiv) {
        // T√¶l antallet af tapsteder, der er markeret som "Lejlighed"
        // Vi kigger direkte i DOM'en (table rows) for at f√• den aktuelle status
        const apartmentCount = document.querySelectorAll('.tapsted-container > tr[data-is-apartment="true"]').length;
        
        if (apartmentCount === 0) {
            warningDiv.classList.remove('d-none'); // Vis advarsel
        } else {
            warningDiv.classList.add('d-none'); // Skjul advarsel
        }
    } else if (warningDiv) {
        warningDiv.classList.add('d-none'); // Skjul altid hvis ikke Metode A
    }
}

/**
 * Tilf√∏jer en ny r√¶kke til tappem√∏nster-tabellen for Metode C.
 */
function addTappemonsterRow() {
    const tbody = document.getElementById('metodeC_tablebody');
    tbody.insertAdjacentHTML('beforeend', `
        <tr>
            <td><input type="number" step="0.01" class="form-control form-control-sm" value="0.15"></td>
            <td><input type="number" class="form-control form-control-sm" value="5"></td>
            <td><input type="number" class="form-control form-control-sm" value="5"></td>
            <td><button class="btn btn-sm btn-outline-danger" onclick="this.closest('tr').remove()">&times;</button></td>
        </tr>
    `);
}

/**
 * Hovedfunktion der kaldes, n√•r "Beregn Beholder" klikkes.
 * Den afl√¶ser den valgte metode og kalder den relevante beregningsfunktion.
 */
function beregnBeholder() {
    const valg = document.querySelector('input[name="beholderMetode"]:checked').value;
    let resultat = { volumen: 0, beskrivelse: '' };
    const config = getGlobalConfig(); 

    try {
        if (valg === 'A') {
            resultat = beregnBeholderMetodeA();
        } else if (valg === 'B') {
            resultat = beregnBeholderMetodeB(config.T_v);
        } else if (valg === 'C') {
            resultat = beregnBeholderMetodeC(config.T_v);
        }
    } catch (e) {
        alert(`Der opstod en fejl under beregningen: ${e.message}`);
        return;
    }

    // --- NYT: TJEK CIRKULATIONSFLOW VS VOLUMEN ---
    // Vi henter det samlede cirkulationsflow fra den senest beregnede model
    if (state.lastModel && state.lastModel.loops) {
        const totalCircFlowLH = state.lastModel.loops.reduce((sum, l) => sum + (l.circ_flow || 0), 0) * 3600;
        
        // Tjek: Er Flow (l/h) > Volumen (L)? (Hvilket svarer til m3/h > m3)
        // Vi bruger en lille margen (fx > 100%) for at udl√∏se advarslen
        if (totalCircFlowLH > resultat.volumen && resultat.volumen > 0) {
            resultat.beskrivelse += `
                <div class="alert alert-warning mt-3">
                    <h6>‚ö†Ô∏è Advarsel: Beholder muligvis for lille til cirkulationen</h6>
                    <p class="mb-1">Det beregnede cirkulationsflow er <b>${totalCircFlowLH.toFixed(0)} l/h</b>, hvilket er st√∏rre end beholdervolumenet p√• <b>${resultat.volumen.toFixed(0)} L</b>.</p>
                    <p class="mb-1">Dette medf√∏rer risiko for at √∏del√¶gge temperaturlagdelingen i beholderen og dermed problemer med at opretholde temperaturen.</p>
                    <hr>
                    <strong>Anbefalede tiltag:</strong>
                    <ul class="mb-0 ps-3">
                        <li>Overvej en <b>supplerende cirkulationsveksler</b>.</li>
                        <li>Fors√∏g at <b>reducere den cirkulerede vandm√¶ngde</b> (bedre isolering, mindre r√∏r).</li>
                        <li>Tjek om der er tapsteder langt v√¶k fra hovedsystemet, som med fordel kunne forsynes med <b>decentral varmtvandsopvarmning</b>.</li>
						<li>Tjek brugsvandssystemet med fordel kan deles op i <b>mindre enheder</b></li>
                    </ul>
                </div>
            `;
        }
    }
    // --- SLUT P√Ö NYT ---

    // Vis resultatet
    document.getElementById('beholderResultatVolumen').textContent = `${resultat.volumen.toFixed(0)} L`;
    document.getElementById('beholderResultatBeskrivelse').innerHTML = resultat.beskrivelse;
}

/**
 * Metode A: Interaktiv P-V kurve beregning for etagebyggeri.
 */
function beregnBeholderMetodeA() {
    const model = state.lastModel; // Hent model fra sidste fulde beregning

    if (!model || !model.N || model.N <= 0) {
        throw new Error('Metode A kr√¶ver, at der f√∏rst k√∏res en fuld systemberegning med tapsteder af typen "Lejlighed".');
    }

    const userEffekt = parseFloat(document.getElementById('userEffekt')?.value);
    const userVolumen = parseFloat(document.getElementById('userVolumen')?.value);
    const N = model.N;
    const n_keys = Object.keys(model.pv_kurver).map(Number);
    const closest_n = n_keys.reduce((p, c) => (Math.abs(c - N) < Math.abs(p - N) ? c : p));
    const kurve = model.pv_kurver[closest_n];
    const kurveVol = Object.keys(kurve).map(Number);
    const kurveEff = Object.values(kurve);

    let beregnetVolumen = 0;
    let beskrivelse = 'Indtast enten tilg√¶ngelig effekt eller √∏nsket volumen i felterne ovenfor for at beregne den anden v√¶rdi.';

    if (!isNaN(userEffekt) && userEffekt > 0) {
        const effektPrLejl = userEffekt / N;
        const volPrLejl = interpolate(effektPrLejl, [...kurveEff].reverse(), [...kurveVol].reverse());
        beregnetVolumen = volPrLejl * N;
        beskrivelse = `For en tilg√¶ngelig effekt p√• <b>${userEffekt} kW</b>, kr√¶ves et beholdervolumen p√• ca. <b>${beregnetVolumen.toFixed(0)} L</b>.`;
        document.getElementById('userVolumen').value = ''; // Ryd det andet felt
    } else if (!isNaN(userVolumen) && userVolumen > 0) {
        const volPrLejl = userVolumen / N;
        const effektPrLejl = interpolate(volPrLejl, kurveVol, kurveEff);
        const beregnetEffekt = effektPrLejl * N;
        beregnetVolumen = userVolumen; // Volumen er det indtastede
        beskrivelse = `For et √∏nsket volumen p√• <b>${userVolumen} L</b>, er det n√∏dvendige effektbehov ca. <b>${beregnetEffekt.toFixed(1)} kW</b>.`;
        document.getElementById('userEffekt').value = ''; // Ryd det andet felt
    } else {
         throw new Error("Indtast venligst enten en gyldig effekt eller et volumen for Metode A.");
    }

    return {
        volumen: beregnetVolumen,
        beskrivelse: beskrivelse
    };
}

/**
 * Metode B: Simpel beregning baseret p√• st√∏rste enkeltforbruger.
 * @param {number} T_v - Freml√∏bstemperatur i ¬∞C.
 */
function beregnBeholderMetodeB(T_v) {
    const flow_ls = parseFloat(document.getElementById('metodeB_flow').value);
    const varighed_min = parseFloat(document.getElementById('metodeB_varighed').value);
    const effekt_kW = parseFloat(document.getElementById('metodeB_effekt').value);
    
    if (isNaN(flow_ls) || isNaN(varighed_min) || isNaN(effekt_kW)) throw new Error("Ugyldige inputv√¶rdier.");

    const T_kold = 10; // Antaget koldtvandstemperatur i ¬∞C
    const delta_T = T_v - T_kold;
    const varighed_s = varighed_min * 60;

    // Energi (Joule) der kr√¶ves for at opvarme vandet
    const total_vand_L = flow_ls * varighed_s;
    const energi_kr√¶vet_J = total_vand_L * C * delta_T;

    // Energi (Joule) som varmekilden leverer i perioden
    const effekt_W = effekt_kW * 1000;
    const energi_leveret_J = effekt_W * varighed_s;

    // Underskud af energi, som beholderen skal levere
    const energi_underskud_J = Math.max(0, energi_kr√¶vet_J - energi_leveret_J);

    // Konverter energi-underskuddet tilbage til et volumen i liter
    const volumen_L = energi_underskud_J / (C * delta_T);

    return {
        volumen: volumen_L,
        beskrivelse: `Beregnet ud fra et spidsforbrug p√• ${total_vand_L.toFixed(0)} L over ${varighed_min} minutter med en varmekilde p√• ${effekt_kW} kW.`
    };
}

/**
 * Metode C: Detaljeret beregning baseret p√• tappem√∏nster.
 * @param {number} T_v - Freml√∏bstemperatur i ¬∞C.
 */
function beregnBeholderMetodeC(T_v) {
    const effekt_kW = parseFloat(document.getElementById('metodeC_effekt').value);
    if (isNaN(effekt_kW)) throw new Error("Ugyldig effektv√¶rdi.");

    const r√¶kker = document.querySelectorAll('#metodeC_tablebody tr');
    let tappem√∏nster = [];
    let max_tid_s = 0;

    r√¶kker.forEach(r => {
        const inputs = r.querySelectorAll('input');
        const flow_ls = parseFloat(inputs[0].value);
        const start_min = parseFloat(inputs[1].value);
        const varighed_min = parseFloat(inputs[2].value);
        if (![flow_ls, start_min, varighed_min].some(isNaN)) {
            const start_s = start_min * 60;
            const slut_s = start_s + (varighed_min * 60);
            tappem√∏nster.push({ flow_ls, start_s, slut_s });
            if (slut_s > max_tid_s) max_tid_s = slut_s;
        }
    });

    if (tappem√∏nster.length === 0) return { volumen: 0, beskrivelse: "Intet tappem√∏nster defineret." };
    
    const T_kold = 10; // Antaget koldtvandstemperatur
    const delta_T = T_v - T_kold;
    const effekt_W = effekt_kW * 1000;
    
    let maks_energi_underskud_J = 0;
    let nuv√¶rende_energi_underskud_J = 0;

    // Simuler sekund for sekund
    for (let t = 0; t <= max_tid_s; t++) {
        let nuv√¶rende_flow_ls = 0;
        tappem√∏nster.forEach(tap => {
            if (t >= tap.start_s && t < tap.slut_s) {
                nuv√¶rende_flow_ls += tap.flow_ls;
            }
        });

        const energi_forbrugt_J_pr_s = nuv√¶rende_flow_ls * C * delta_T;
        const energi_leveret_J_pr_s = effekt_W;

        nuv√¶rende_energi_underskud_J += (energi_forbrugt_J_pr_s - energi_leveret_J_pr_s);
        
        // Underskud kan ikke v√¶re negativt (beholderen kan ikke v√¶re "mere end fuld")
        if (nuv√¶rende_energi_underskud_J < 0) {
            nuv√¶rende_energi_underskud_J = 0;
        }
        
        if (nuv√¶rende_energi_underskud_J > maks_energi_underskud_J) {
            maks_energi_underskud_J = nuv√¶rende_energi_underskud_J;
        }
    }

    const volumen_L = maks_energi_underskud_J / (C * delta_T);

    return {
        volumen: volumen_L,
        beskrivelse: `Beregnet ud fra et detaljeret tappem√∏nster over ${Math.ceil(max_tid_s / 60)} minutter. Det maksimale energiunderskud kr√¶ver et lagervolumen p√• ${volumen_L.toFixed(0)} L.`
    };
}

/**
 * Fremh√¶ver en specifik cirkulationsstreng i D3-diagrammet.
 */
function highlightLoop(loopId) {
    if (!state.lastModel) return;
    const loop = state.lastModel.loops.find(l => l.id === loopId);
    if (!loop || !loop.path) return;

    const pathIds = new Set(loop.path);

    // RETTELSE: Inkluderer nu .link-cirkulation_vv i selektoren
    d3.selectAll("#diagram svg .link-freml√∏b, #diagram svg .link-cirkulation_vv")
        .each(function(d) {
            const link = d3.select(this);
            const isPartOfPath = pathIds.has(d.target.id);

            if (isPartOfPath) {
                link.style('stroke', '#ff7f0e').style('stroke-width', '4px').style('opacity', 1.0);
            } else {
                link.style('opacity', 0.1);
            }
        });
}

/**
 * Fremh√¶ver en enkelt komponent (r√∏r) i diagrammet.
 */
function highlightComponent(id) {
    // D√¶mp alle links
    // RETTELSE: Inkluderer nu .link-cirkulation_vv
    d3.selectAll("#diagram svg .link-freml√∏b, #diagram svg .link-cirkulation_vv")
        .style('opacity', 0.1);

    // Find og fremh√¶v det specifikke link
    d3.selectAll("#diagram svg .link-freml√∏b, #diagram svg .link-cirkulation_vv")
        .filter(d => d.target.id === id)
        .style('stroke', '#ff7f0e') 
        .style('stroke-width', '6px')
        .style('opacity', 1.0);
}

function clearHighlight() {
    updateDiagramStyles(); // Nulstiller til normal visning
}

	
/**
 * H√•ndterer venstre-klik p√• en node. Enten for at redigere, eller for at f√¶rdigg√∏re en forbindelse.
 * @param {object} event - Klik-eventet.
 * @param {object} d - Data-objektet for den klikkede node.
 */
function handleNodeClick(event, d) {
    // Tjek om vi er i "forbindelsestilstand"
    if (state.connectingNodeInfo) {
        event.preventDefault();
        event.stopPropagation();

        const sourceInfo = state.connectingNodeInfo;
        const targetNodeData = d;
        const sourceElement = document.querySelector(`tr[data-id="${sourceInfo.nodeData.id}"], div[data-id="${sourceInfo.nodeData.id}"]`);

        if (sourceInfo.type === 'parent' && sourceElement) {
            const isSourceReturn = ['cirkulation_vv', 'valve'].includes(sourceInfo.nodeData.type);
            const isTargetReturn = ['cirkulation_vv', 'valve', 'beholder'].includes(targetNodeData.type);
            const isTargetSupply = ['ror_vv', 'beholder'].includes(targetNodeData.type);

            // En forbindelse er gyldig hvis:
            // 1. Kilden er en retur-del OG m√•let er en retur-del.
            // 2. Kilden er en freml√∏bs-del OG m√•let er en freml√∏bs-del.
            // 3. M√•let ikke er et tapsted (man kan ikke forbinde TIL et tapsted).
            // 4. Man ikke forbinder til sig selv.
            const isValidConnection = (isSourceReturn && isTargetReturn) || (!isSourceReturn && isTargetSupply);
            
            if (isValidConnection && sourceInfo.nodeData.id !== targetNodeData.id && targetNodeData.type !== 'tapsted') {
                sourceElement.querySelector('.parent').value = targetNodeData.id;
            } else {
                console.warn("Ugyldig forbindelse fors√∏gt.");
            }
        }
        
        if (sourceInfo.type === 'return') {
            // Denne logik h√•ndterer "Forbind til retur..."
            if (['cirkulation_vv', 'valve', 'beholder'].includes(targetNodeData.type)) {
                const strengId = sourceInfo.nodeData.id.split('-')[0];
                const strengCard = document.querySelector(`.streng-card[data-id="${strengId}"]`);
                if (strengCard) {
                    strengCard.querySelector('.circ-start').value = sourceInfo.nodeData.id;
                    strengCard.querySelector('.circ-end').value = targetNodeData.id;
                }
            }
        }
        
        // Nulstil og opdater
        state.connectingNodeInfo = null;
        document.body.style.cursor = 'default';
        updateAllSelects();
        return;
    }

    // --- Normal "Klik for at redigere" logik ---
    const element = document.querySelector(`tr[data-id="${d.id}"], div[data-id="${d.id}"]`);
    if (!element) return;

    document.querySelectorAll('.highlighted-row').forEach(el => el.classList.remove('highlighted-row'));
    element.classList.add('highlighted-row');
    element.scrollIntoView({ behavior: 'smooth', block: 'center' });

    setTimeout(() => {
        element.classList.remove('highlighted-row');
    }, 2500);
}

/**
 * H√•ndterer h√∏jre-klik p√• en node for at vise en kontekstmenu.
 * @param {object} event - H√∏jreklik-eventet.
 * @param {object} d - Data-objektet for den klikkede node.
 * Indeholder undermenuer og logik for alle komponenttyper.
 * Indeholder fuld underst√∏ttelse for b√•de freml√∏b og retur (kopier/inds√¶t/opdel)
 */
function handleNodeRightClick(event, d) {
    event.preventDefault();
    removeContextMenu();

    const menu = document.createElement('div');
    menu.id = 'context-menu';
    menu.style.position = 'absolute';
    menu.style.left = `${event.pageX}px`;
    menu.style.top = `${event.pageY}px`;
    menu.style.background = 'white';
    menu.style.border = '1px solid #ccc';
    menu.style.borderRadius = '5px';
    menu.style.boxShadow = '2px 2px 5px rgba(0,0,0,0.2)';
    menu.style.padding = '5px 0';
    menu.style.zIndex = '1000';

    // Helper til at lave menupunkter
    const createMenuItem = (text, onClick, hasSubmenu = false) => {
        const item = document.createElement('div');
        item.textContent = text;
        item.className = 'menu-item'; 
        if (hasSubmenu) item.classList.add('has-submenu');
        
        if (onClick) {
            item.onclick = (e) => {
                e.stopPropagation(); 
                onClick();
                removeContextMenu();
            };
        }
        return item;
    };

    const nodeType = d.type || (d.id === 'Beholder' ? 'beholder' : null);

    // --- 1. FORBINDELSER & FLYTNING (F√¶lles) ---
    if (nodeType === 'ror_vv' || nodeType === 'cirkulation_vv' || nodeType === 'valve') {
        menu.appendChild(createMenuItem('Forbind til...', () => {
            state.connectingNodeInfo = { nodeData: d, type: 'parent' };
            document.body.style.cursor = 'crosshair';
        }));
    }
    if (nodeType === 'ror_vv') {
        menu.appendChild(createMenuItem('Forbind til cirkulation VV...', () => {
            state.connectingNodeInfo = { nodeData: d, type: 'return' };
            document.body.style.cursor = 'crosshair';
        }));
    }
    
    // Flyt gren (F√¶lles for r√∏r/retur/ventil, men ikke beholder)
    if (nodeType !== 'beholder' && nodeType !== 'tapsted') {
        menu.appendChild(createMenuItem('Flyt gren herfra', () => {
            // Timeout for at lade menuen lukke f√∏r drag starter
            setTimeout(() => startMoveBranch(d.id), 50);
        }));
    }
    
    if (menu.hasChildNodes()) menu.appendChild(document.createElement('hr')).style.margin = '5px 0';


    // --- 2. AVANCEREDE FUNKTIONER (Opdel & Kopier) ---
    
    // Opdel R√∏r (G√¶lder b√•de freml√∏b og retur)
    if (nodeType === 'ror_vv' || nodeType === 'cirkulation_vv') {
        menu.appendChild(createMenuItem('Opdel r√∏r...', () => {
            const segments = prompt("Antal segmenter r√∏rstykket skal opdeles i:", "2");
            if (segments) {
                const count = parseInt(segments, 10);
                if (!isNaN(count) && count > 1) splitPipe(d.id, count);
            }
        }));
        
        // Kopier gren (G√¶lder nu b√•de freml√∏b og retur)
        menu.appendChild(createMenuItem('Kopier gren herfra', () => {
            copyBranch(d.id);
        }));
    }

    // --- 3. INDS√ÜT (Paste) LOGIK ---
    if (state.clipboard) {
        const clipType = state.clipboard.type;
        const isSupplyClip = ['ror_vv', 'tapsted'].includes(clipType);
        const isReturnClip = ['cirkulation_vv', 'valve'].includes(clipType);

        // SCENARIE A: Inds√¶t p√• Freml√∏bsr√∏r (Submenu: I denne / Ny streng)
        if (nodeType === 'ror_vv' && isSupplyClip) {
            const pasteItem = createMenuItem('Inds√¶t...', null, true);
            
            const submenu = document.createElement('div');
            submenu.className = 'context-submenu';
            
            const subItem1 = document.createElement('div');
            subItem1.className = 'menu-item';
            subItem1.textContent = 'I denne VV-streng';
            subItem1.onclick = () => { pasteBranch(d.id, 'current'); removeContextMenu(); };
            submenu.appendChild(subItem1);
            
            const subItem2 = document.createElement('div');
            subItem2.className = 'menu-item';
            subItem2.textContent = 'Som ny VV-streng';
            subItem2.onclick = () => { pasteBranch(d.id, 'new'); removeContextMenu(); };
            submenu.appendChild(subItem2);
            
            pasteItem.appendChild(submenu);
            menu.appendChild(pasteItem);
        }
        
        // SCENARIE B: Inds√¶t p√• Retur/Ventil (Direkte: I denne streng)
        else if ((nodeType === 'cirkulation_vv' || nodeType === 'valve') && isReturnClip) {
             menu.appendChild(createMenuItem('Inds√¶t kopieret gren', () => {
                pasteBranch(d.id, 'current');
            }));
        }
        
        // SCENARIE C: Inds√¶t p√• Beholder
        else if (nodeType === 'beholder') {
            if (isSupplyClip) {
                 // Freml√∏b p√• Beholder -> Altid ny streng
                 menu.appendChild(createMenuItem('Inds√¶t som ny VV-streng', () => {
                    pasteBranch(d.id, 'new'); 
                }));
            } else if (isReturnClip) {
                 // Retur p√• Beholder -> Forbindes direkte
                 menu.appendChild(createMenuItem('Inds√¶t kopieret gren', () => {
                    pasteBranch(d.id, 'current');
                }));
            }
        }
    }
    
    if (menu.hasChildNodes() && menu.lastChild.tagName !== 'HR') {
         menu.appendChild(document.createElement('hr')).style.margin = '5px 0';
    }

    // --- 4. TILF√òJ KOMPONENTER MANUELT ---
    
    // Freml√∏b
    if (nodeType === 'ror_vv') {
        menu.appendChild(createMenuItem('Tilf√∏j VV r√∏r her', () => {
            const parentId = d.id; 
            const strengId = parentId.split('-')[0];
            const strengCard = document.querySelector(`.streng-card[data-id="${strengId}"]`);
            if (strengCard) {
                const addRorButton = strengCard.querySelector('button[aria-label="Tilf√∏j r√∏r"]');
                if (addRorButton) {
                    addRorSektion(addRorButton);
                    const newPipe = strengCard.querySelector('.ror-container > tr[data-type="ror_vv"]:last-child');
                    if (newPipe) { newPipe.querySelector('.parent').value = parentId; updateAllSelects(); }
                }
            }
        }));
        menu.appendChild(createMenuItem('Tilf√∏j tapsted her', () => {
            const parentId = d.id; 
            const strengId = parentId.split('-')[0];
            const strengCard = document.querySelector(`.streng-card[data-id="${strengId}"]`);
            if (strengCard) {
                const addTapstedButton = strengCard.querySelector('button[aria-label="Tilf√∏j tapsted"]');
                if (addTapstedButton) {
                    addTapsted(addTapstedButton);
                    const newTap = strengCard.querySelector('.tapsted-container > tr[data-type="tapsted"]:last-child');
                    if (newTap) { newTap.querySelector('.parent').value = parentId; updateAllSelects(); }
                }
            }
        }));
    }

    // Ny Streng (Fra Beholder eller R√∏r)
    if (nodeType === 'beholder' || nodeType === 'ror_vv') {
        menu.appendChild(createMenuItem('Tilf√∏j ny VV-streng herfra', () => {
            addStreng_vv();
            const newStreng = document.querySelector('.streng-card:last-child');
            if (newStreng) {
                const firstPipe = newStreng.querySelector('.ror-container > tr[data-type="ror_vv"]');
                if (firstPipe) { firstPipe.querySelector('.parent').value = d.id; updateAllSelects(); }
            }
        }));
    }

    // Retur komponenter
    if (nodeType === 'beholder' || nodeType === 'cirkulation_vv' || nodeType === 'valve') {
        menu.appendChild(createMenuItem('Tilf√∏j Cirkulationsr√∏r her', () => {
            addCirkulationRor();
            const newEl = document.querySelector('#returContainerBody > tr[data-type="cirkulation_vv"]:last-child');
            if (newEl) { newEl.querySelector('.parent').value = d.id; updateAllSelects(); }
        }));
        menu.appendChild(createMenuItem('Tilf√∏j Cirkulationsventil her', () => {
            addValve();
            const newEl = document.querySelector('#returContainerBody > tr[data-type="valve"]:last-child');
            if (newEl) { newEl.querySelector('.parent').value = d.id; updateAllSelects(); }
        }));
    }

    // --- 5. SLET (Alle undtagen Beholder) ---
    if (nodeType !== 'beholder') {
        if (menu.hasChildNodes() && menu.lastChild.tagName !== 'HR') {
             menu.appendChild(document.createElement('hr')).style.margin = '5px 0';
        }
        menu.appendChild(createMenuItem('Slet Komponent', () => {
            const element = document.querySelector(`tr[data-id="${d.id}"], div[data-id="${d.id}"]`);
            if (element) {
                // Vi leder efter knappen med aria-label "Fjern..."
                const uiDeleteButton = element.querySelector('button[aria-label*="Fjern"]');
                if (uiDeleteButton) uiDeleteButton.click();
            }
        }));
    }
    
    if (menu.hasChildNodes()) {
        document.body.appendChild(menu);
        setTimeout(() => window.addEventListener('click', removeContextMenu, { once: true }), 0);
    }
}

/**
 * NY FUNKTION (Fase 4): Starter flytning af en hel gren.
 * L√•ser noderne fast til musen og snapper til GRID.
 * Bruger "Delta-Snap" for at bevare figurens form og sikre tydeligt grid-snap.
 */
function startMoveBranch(rootId) {
    // 1. Identificer alle noder i grenen
    const branchNodes = [];
    
    const collectNodes = (id) => {
        const node = state.nodes.find(n => n.id === id);
        if (node) branchNodes.push(node);
        
        document.querySelectorAll('.parent').forEach(select => {
            if (select.value === id) {
                const childId = select.closest('tr').dataset.id;
                collectNodes(childId);
            }
        });
    };
    
    collectNodes(rootId);
    if (branchNodes.length === 0) return;

    // 2. Find musens start-position i diagram-koordinater
    const svgNode = d3.select('#diagram svg').node();
    // Hvis vi ikke har et event (kaldt fra menu), bruger vi rod-nodens position som "musens startpunkt"
    const rootNode = state.nodes.find(n => n.id === rootId);
    const startX = (rootNode.fx !== undefined && rootNode.fx !== null) ? rootNode.fx : rootNode.x;
    const startY = (rootNode.fy !== undefined && rootNode.fy !== null) ? rootNode.fy : rootNode.y;
    
    // 3. Gem start-data (Oprindelige positioner)
    state.movingBranch = {
        nodes: branchNodes,
        startMouseX: startX,
        startMouseY: startY,
        // Gem den oprindelige faste position for hver node
        initialPositions: branchNodes.map(n => ({
            id: n.id,
            fx: (n.fx !== undefined && n.fx !== null) ? n.fx : n.x,
            fy: (n.fy !== undefined && n.fy !== null) ? n.fy : n.y
        }))
    };

    // Visuel feedback (R√∏d markering)
    d3.selectAll('.node').filter(d => branchNodes.some(bn => bn.id === d.id))
        .select('circle, rect')
        .style('stroke', '#ff0000')
        .style('stroke-width', '3px');

    // 4. Tilf√∏j event listeners til HELE SVG'en
    const svg = d3.select('#diagram svg');
    
    svg.on('mousemove.branchMove', function(event) {
        // Konverter musens pixel-koordinater til diagram-koordinater
        const transform = d3.zoomTransform(this);
        const [mx, my] = d3.pointer(event);
        const currentX = transform.invertX(mx);
        const currentY = transform.invertY(my);
        
        // Beregn bev√¶gelsen (Delta)
        const dx = currentX - state.movingBranch.startMouseX;
        const dy = currentY - state.movingBranch.startMouseY;

        // SNAP DELTA TIL GRID (Global gridSize = 10)
        const snappedDx = Math.round(dx / gridSize) * gridSize;
        const snappedDy = Math.round(dy / gridSize) * gridSize;
        
        // Opdater positioner
        state.movingBranch.nodes.forEach((node, i) => {
            const initial = state.movingBranch.initialPositions[i];
            
            // Ny position = Oprindelig + Snappet Flytning
            node.fx = initial.fx + snappedDx;
            node.fy = initial.fy + snappedDy;
            
            // TVING VISUEL OPDATERING STRAKS (Fjerner "elastik"-effekt)
            node.x = node.fx;
            node.y = node.fy;
        });
        
        // Opdater diagrammet (links f√∏lger med)
        state.sim.alpha(1).restart();
        state.sim.tick(); // Tvinger D3 til at opdatere links med det samme
    });

    // Klik for at slippe
    svg.on('click.branchMove', function() {
        stopMoveBranch();
    });
    
    // H√∏jreklik for at annullere
    svg.on('contextmenu.branchMove', function(event) {
        event.preventDefault();
        stopMoveBranch();
    });
    
    // Skift mark√∏r
    document.body.style.cursor = 'grabbing';
}


/**
 * Stopper flytningen og gemmer positionerne.
 */
function stopMoveBranch() {
    if (!state.movingBranch) return;
    
    // Fjern event listeners
    const svg = d3.select('#diagram svg');
    svg.on('mousemove.branchMove', null);
    svg.on('click.branchMove', null);
    svg.on('contextmenu.branchMove', null);
    
    // Fjern visuel markering
    d3.selectAll('.node circle, .node rect')
        .style('stroke', null)
        .style('stroke-width', null);
        
    document.body.style.cursor = 'default';
    
    // Ryd state
    state.movingBranch = null;
    
    // Fort√¶l systemet at vi har √¶ndret noget (s√• auto-gem virker)
    setProjektEr√Ündret();
    
    // Genopfrisk diagrammet for at v√¶re sikker p√• styles
    updateDiagramStyles();
}

/**
 * Fjerner kontekstmenuen fra siden.
 */
function removeContextMenu() {
    const menu = document.getElementById('context-menu');
    if (menu) {
        menu.remove();
    }
}
</script>
</body>
</html>
